{"/home/travis/build/npmtest/node-npmtest-slack-client/test.js":"/* istanbul instrument in package npmtest_slack_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-slack-client/lib.npmtest_slack_client.js":"/* istanbul instrument in package npmtest_slack_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_slack_client = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_slack_client = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-slack-client/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-slack-client && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_slack_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_slack_client\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_slack_client.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_slack_client.rollup.js'] =\n            local.assetsDict['/assets.npmtest_slack_client.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_slack_client.__dirname + '/lib.npmtest_slack_client.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/index.js":"var events = require('./lib/clients/events');\n\nmodule.exports = {\n  WebClient: require('./lib/clients/web/client'),\n  RtmClient: require('./lib/clients/rtm/client'),\n  LegacyRtmClient: require('./lib/clients/default/legacy-rtm'),\n  CLIENT_EVENTS: {\n    WEB: events.CLIENT_EVENTS.WEB,\n    RTM: events.CLIENT_EVENTS.RTM,\n  },\n  RTM_EVENTS: events.RTM_EVENTS,\n  RTM_MESSAGE_SUBTYPES: events.RTM_MESSAGE_SUBTYPES,\n  MemoryDataStore: require('./lib/data-store/memory-data-store'),\n};\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/events/index.js":"module.exports = {\n  CLIENT_EVENTS: {\n    WEB: require('./client').WEB,\n    RTM: require('./client').RTM,\n  },\n  RTM_EVENTS: require('./rtm').EVENTS,\n  RTM_MESSAGE_SUBTYPES: require('./rtm').MESSAGE_SUBTYPES,\n};\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/events/client.js":"/**\n * API client events.\n */\n\nmodule.exports.WEB = {\n  RATE_LIMITED: 'rate_limited',\n};\n\nmodule.exports.RTM = {\n  CONNECTING: 'connecting',                     // the rtm.start API call has been made, but the\n                                                // response has not come back\n\n  AUTHENTICATED: 'authenticated',               // rtm.start returned successfully with a websocket\n                                                // URL to connect to\n\n  WS_OPENING: 'ws_opening',                     // the underlying websocket connection is being\n                                                // opened\n\n  WS_OPENED: 'ws_opened',                       // the underlying websocket connection has opened\n                                                // and messages can be received from the remote\n\n  RTM_CONNECTION_OPENED: 'open',                // the remote server has acked the socket and sent a\n                                                // `hello` message, the connection is now live and\n                                                // can be used to send messages\n\n  DISCONNECT: 'disconnect',                     // the RTM client has disconnected and will not try\n                                                // to reconnect again automatically\n\n  UNABLE_TO_RTM_START: 'unable_to_rtm_start',   // the rtm.start API call failed in some way, this\n                                                // may be recoverable\n\n  WS_CLOSE: 'ws_close',                         // the underlying websocket connection was closed. A\n                                                // reconnect may be attempted after this\n\n  WS_ERROR: 'ws_error',                         // the underlying websocket connection threw an\n                                                // an error\n\n  ATTEMPTING_RECONNECT: 'attempting_reconnect', // the client is attempting to initiate a reconnect\n\n  RAW_MESSAGE: 'raw_message',                   // a message was received from the RTM API. This\n                                                // will also contain the raw message payload that\n                                                // was sent from Slack\n};\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/events/rtm.js":"/**\n * Events sent by the Slack RTM API.\n *\n * NOTE: This file was auto-generated and should not be edited manually.\n */\n\nmodule.exports.EVENTS = {\n  ACCOUNTS_CHANGED: 'accounts_changed',\n  COMMANDS_CHANGED: 'commands_changed',\n  EMAIL_DOMAIN_CHANGED: 'email_domain_changed',\n  EMOJI_CHANGED: 'emoji_changed',\n  HELLO: 'hello',\n  MANUAL_PRESENCE_CHANGE: 'manual_presence_change',\n  MESSAGE: 'message',\n  PREF_CHANGE: 'pref_change',\n  PRESENCE_CHANGE: 'presence_change',\n  BOT_ADDED: 'bot_added',\n  BOT_CHANGED: 'bot_changed',\n  CHANNEL_ARCHIVE: 'channel_archive',\n  CHANNEL_CREATED: 'channel_created',\n  CHANNEL_DELETED: 'channel_deleted',\n  CHANNEL_HISTORY_CHANGED: 'channel_history_changed',\n  CHANNEL_JOINED: 'channel_joined',\n  CHANNEL_LEFT: 'channel_left',\n  CHANNEL_MARKED: 'channel_marked',\n  CHANNEL_RENAME: 'channel_rename',\n  CHANNEL_UNARCHIVE: 'channel_unarchive',\n  FILE_CHANGE: 'file_change',\n  FILE_COMMENT_ADDED: 'file_comment_added',\n  FILE_COMMENT_DELETED: 'file_comment_deleted',\n  FILE_COMMENT_EDITED: 'file_comment_edited',\n  FILE_CREATED: 'file_created',\n  FILE_DELETED: 'file_deleted',\n  FILE_PRIVATE: 'file_private',\n  FILE_PUBLIC: 'file_public',\n  FILE_SHARED: 'file_shared',\n  FILE_UNSHARED: 'file_unshared',\n  GROUP_ARCHIVE: 'group_archive',\n  GROUP_CLOSE: 'group_close',\n  GROUP_HISTORY_CHANGED: 'group_history_changed',\n  GROUP_JOINED: 'group_joined',\n  GROUP_LEFT: 'group_left',\n  GROUP_MARKED: 'group_marked',\n  GROUP_OPEN: 'group_open',\n  GROUP_RENAME: 'group_rename',\n  GROUP_UNARCHIVE: 'group_unarchive',\n  IM_CLOSE: 'im_close',\n  IM_CREATED: 'im_created',\n  IM_HISTORY_CHANGED: 'im_history_changed',\n  IM_MARKED: 'im_marked',\n  IM_OPEN: 'im_open',\n  MPIM_CLOSE: 'mpim_close',\n  MPIM_JOINED: 'mpim_joined',\n  MPIM_OPEN: 'mpim_open',\n  PIN_ADDED: 'pin_added',\n  PIN_REMOVED: 'pin_removed',\n  REACTION_ADDED: 'reaction_added',\n  REACTION_REMOVED: 'reaction_removed',\n  STAR_ADDED: 'star_added',\n  STAR_REMOVED: 'star_removed',\n  TEAM_DOMAIN_CHANGE: 'team_domain_change',\n  TEAM_JOIN: 'team_join',\n  TEAM_MIGRATION_STARTED: 'team_migration_started',\n  TEAM_PLAN_CHANGE: 'team_plan_change',\n  TEAM_PREF_CHANGE: 'team_pref_change',\n  TEAM_RENAME: 'team_rename',\n  USER_CHANGE: 'user_change',\n  USER_TYPING: 'user_typing',\n};\n\nmodule.exports.MESSAGE_SUBTYPES = {\n  BOT_MESSAGE: 'bot_message',\n  ME_MESSAGE: 'me_message',\n  PINNED_ITEM: 'pinned_item',\n  UNPINNED_ITEM: 'unpinned_item',\n  CHANNEL_ARCHIVE: 'channel_archive',\n  CHANNEL_JOIN: 'channel_join',\n  CHANNEL_LEAVE: 'channel_leave',\n  CHANNEL_NAME: 'channel_name',\n  CHANNEL_PURPOSE: 'channel_purpose',\n  CHANNEL_TOPIC: 'channel_topic',\n  CHANNEL_UNARCHIVE: 'channel_unarchive',\n  FILE_COMMENT: 'file_comment',\n  FILE_MENTION: 'file_mention',\n  FILE_SHARE: 'file_share',\n  GROUP_ARCHIVE: 'group_archive',\n  GROUP_JOIN: 'group_join',\n  GROUP_LEAVE: 'group_leave',\n  GROUP_NAME: 'group_name',\n  GROUP_PURPOSE: 'group_purpose',\n  GROUP_TOPIC: 'group_topic',\n  GROUP_UNARCHIVE: 'group_unarchive',\n  MESSAGE_CHANGED: 'message_changed',\n  MESSAGE_DELETED: 'message_deleted',\n};\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/client.js":"/**\n *\n */\n\nvar bind = require('lodash').bind;\nvar forEach = require('lodash').forEach;\nvar inherits = require('inherits');\n\nvar BaseAPIClient = require('../client');\nvar facets = require('./facets/index');\n\n\n/**\n * Slack Web API client.\n *\n * @param token The Slack API token to use with this client.\n * @param {Object=} opts\n * @param {Object} opts.retryConfig The configuration to use for the retry operation,\n *     {@see https://github.com/SEAPUNK/node-retry}\n * @constructor\n */\nfunction WebAPIClient(token, opts) {\n  var clientOpts = opts || {};\n\n  BaseAPIClient.call(this, token, clientOpts);\n\n  // Attempts 5 retries within 5 minutes, with exponential backoff\n  this.retryConfig = clientOpts.retryConfig || {\n    retries: 5,\n    factor: 3.9,\n  };\n}\n\ninherits(WebAPIClient, BaseAPIClient);\n\n\n/** @inheritDocs **/\nWebAPIClient.prototype._createFacets = function _createFacets() {\n  var newFacet;\n  var makeAPICall;\n\n  WebAPIClient.super_.prototype._createFacets.call(this);\n\n  makeAPICall = bind(this.makeAPICall, this);\n  forEach(facets, function registerWebClientFacet(Facet) {\n    newFacet = new Facet(makeAPICall);\n    this[newFacet.name] = newFacet;\n  }, this);\n};\n\n\nmodule.exports = WebAPIClient;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/client.js":"/**\n *\n */\n\nvar EventEmitter = require('eventemitter3');\nvar async = require('async');\nvar bind = require('lodash').bind;\nvar inherits = require('inherits');\nvar retry = require('retry');\nvar urlJoin = require('url-join');\n\nvar WEB_CLIENT_EVENTS = require('./events/client').WEB;\nvar getLogger = require('../helpers').getLogger;\nvar helpers = require('./helpers');\nvar requestsTransport = require('./transports/request').requestTransport;\n\n\n/**\n * Base client for both the RTM and web APIs.\n * @param {string} token The Slack API token to use with this client.\n * @param {Object} opts\n * @param {String} opts.slackAPIUrl The Slack API URL.\n * @param {String} opts.userAgent The user-agent to use, defaults to node-slack.\n * @param {Function} opts.transport Function to call to make an HTTP call to the Slack API.\n * @param {string=} opts.logLevel The log level for the logger.\n * @param {Function=} opts.logger Function to use for log calls, takes (logLevel, logString) params.\n * @param {Number} opts.maxRequestConcurrency The max # of concurrent requests to make to Slack's\n *     API's, defaults to 5.\n * @constructor\n */\nfunction BaseAPIClient(token, opts) {\n  EventEmitter.call(this);\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this._token = token;\n\n  /** @type {string} */\n  this.slackAPIUrl = opts.slackAPIUrl || 'https://slack.com/api/';\n\n  /** @type {Function} */\n  this.transport = opts.transport || requestsTransport;\n\n  /** @type {string} */\n  this.userAgent = opts.userAgent || 'node-slack';\n\n  /**\n   *\n   * @type {Object}\n   * @private\n   */\n  this._requestQueue = async.priorityQueue(\n    bind(this._callTransport, this),\n    opts.maxRequestConcurrency\n  );\n\n  /**\n   * The logger function attached to this client.\n   * @type {Function}\n   */\n  this.logger = opts.logger || getLogger(opts.logLevel);\n\n  this._createFacets();\n}\n\ninherits(BaseAPIClient, EventEmitter);\n\n\nBaseAPIClient.prototype.emit = function emit() {\n  BaseAPIClient.super_.prototype.emit.apply(this, arguments);\n  this.logger('debug', arguments);\n};\n\n\n/**\n * Initializes each of the API facets.\n * @protected\n */\nBaseAPIClient.prototype._createFacets = function _createFacets() {\n};\n\n\n/**\n * Attaches a data-store to the client instance.\n * @param {SlackDataStore} dataStore\n */\nBaseAPIClient.prototype.registerDataStore = function registerDataStore(dataStore) {\n  this.dataStore = dataStore;\n};\n\n\n/**\n * Calls the supplied transport function and processes the results.\n *\n * This will also manage 429 responses and retry failed operations.\n *\n * @param {object} task The arguments to pass to the transport.\n * @param {function} queueCb Callback to signal to the request queue that the request has completed.\n * @protected\n */\nBaseAPIClient.prototype._callTransport = function _callTransport(task, queueCb) {\n  // TODO(leah): Add some logging to this function as it's kind of complex\n  var args = task.args;\n  var cb = task.cb;\n  var _this = this;\n\n  var retryOp = retry.operation(this.retryConfig);\n\n  var handleTransportResponse = function handleTransportResponse(err, headers, statusCode, body) {\n    var headerSecs;\n    var headerMs;\n    var httpErr;\n    var jsonResponse;\n    var jsonParseErr;\n\n    if (err) {\n      if (!retryOp.retry(err)) {\n        cb(retryOp.mainError(), null);\n      } else {\n        return;\n      }\n    }\n\n    // NOTE: this assumes that non-200 codes simply won't happen, as the Slack API policy is to\n    //       return a 200 with an error property\n    if (statusCode !== 200) {\n      // There are only a couple of possible bad cases here:\n      //   - 429: the application is being rate-limited. The client is designed to automatically\n      //          respect this\n      //   - 4xx or 5xx: something bad, but probably recoverable, has happened, so requeue the\n      //          request\n\n      if (statusCode === 429) {\n        _this._requestQueue.pause();\n        headerSecs = parseInt(headers['Retry-After'], 10);\n        headerMs = headerSecs * 1000;\n        setTimeout(function retryRateLimitedRequest() {\n          // Don't retry limit requests that were rejected due to retry-after\n          _this.transport(args, handleTransportResponse);\n          _this._requestQueue.resume();\n        }, headerMs);\n\n        _this.emit(WEB_CLIENT_EVENTS.RATE_LIMITED, headerSecs);\n      } else {\n        // If this is reached, it means an error outside the normal error logic was received. These\n        // should be very unusual as standard errors come back with a 200 code and an \"error\"\n        // property.\n        //\n        // Given that, assume that something really weird happened and retry the request as normal.\n\n        httpErr = new Error('Unable to process request, received bad ' + statusCode + ' error');\n        if (!retryOp.retry(httpErr)) {\n          cb(httpErr, null);\n        } else {\n          return;\n        }\n      }\n    } else {\n      try {\n        jsonResponse = JSON.parse(body);\n      } catch (parseErr) {\n        // TODO(leah): Emit an event here?\n        jsonParseErr = new Error('unable to parse Slack API Response');\n      }\n\n      try {\n        cb(jsonParseErr, jsonResponse);\n      } catch (callbackErr) {\n        // Never retry requests that fail in the callback\n        _this.logger('error', callbackErr);\n      }\n    }\n\n    // This is always an empty callback, even if there's an error, as it's used to signal the\n    // request queue that a request has completed processing, and nothing else.\n    queueCb();\n  };\n\n  retryOp.attempt(function attemptTransportCall() {\n    _this.transport(args, handleTransportResponse);\n  });\n};\n\n\n/**\n * Makes a call to the Slack API.\n *\n * @param {String} endpoint The API endpoint to send to.\n * @param {Object=} optData The data send to the Slack API.\n * @param {function} optCb The callback to run on completion.\n */\nBaseAPIClient.prototype.makeAPICall = function makeAPICall(endpoint, optData, optCb) {\n  var apiCallArgs = helpers.getAPICallArgs(this._token, optData, optCb);\n\n  var args = {\n    url: urlJoin(this.slackAPIUrl, endpoint),\n    data: apiCallArgs.data,\n    headers: {\n      'User-Agent': this.userAgent,\n    },\n  };\n\n  this._requestQueue.push({\n    args: args,\n    cb: apiCallArgs.cb,\n  });\n};\n\n\nmodule.exports = BaseAPIClient;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/helpers.js":"/**\n * Top level helpers.\n */\n\nvar ConsoleTransport = require('winston').transports.Console;\nvar bind = require('lodash').bind;\nvar winston = require('winston');\n\n\n/**\n *\n * @param {string} optLogLevel\n * @param {Object} optTransport\n * @returns {function(this:*)|Function|*}\n */\nvar getLogger = function getLogger(optLogLevel, optTransport) {\n  var logger = new winston.Logger({\n    level: optLogLevel || 'info',\n    transports: [optTransport || new ConsoleTransport()],\n  });\n  return bind(logger.log, logger);\n};\n\n\nmodule.exports.getLogger = getLogger;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/helpers.js":"/**\n * Helpers for working with Slack API clients.\n */\n\nvar assign = require('lodash').assign;\nvar isFunction = require('lodash').isFunction;\nvar isUndefined = require('lodash').isUndefined;\nvar isString = require('lodash').isString;\nvar forEach = require('lodash').forEach;\nvar noop = require('lodash').noop;\n\n\n/**\n *\n * @param {object} data\n * @returns {object}\n */\nvar getData = function getData(data, token) {\n  var newData = assign({}, data ? data.opts || {} : {});\n\n  forEach(data || {}, function getValidData(val, key) {\n    if (!isUndefined(val) && val !== null && key !== 'opts') {\n      // For the web API, this should always be a JSON-encoded array, see:\n      //   https://api.slack.com/docs/attachments\n      if (key === 'attachments') {\n        if (isString(val)) {\n          newData[key] = val;\n        } else {\n          newData[key] = JSON.stringify(val);\n        }\n      } else {\n        newData[key] = val;\n      }\n    }\n  });\n\n  // There are a couple of API calls that don't require tokens, so check before passing it through\n  if (token) {\n    newData.token = token;\n  }\n\n  return newData;\n};\n\n\nvar getAPICallArgs = function getAPICallArgs(token, optData, optCb) {\n  var data;\n  var cb;\n\n  if (arguments.length === 1) {\n    // Pass in a no-op function here to avoid adding more conditionals in the _callTransport fn\n    cb = noop;\n    data = getData({}, token);\n  } else if (arguments.length === 2) {\n    if (isFunction(arguments[1])) {\n      cb = arguments[1];\n      data = getData({}, token);\n    } else {\n      cb = noop;\n      data = getData(optData, token);\n    }\n  } else if (arguments.length === 3) {\n    cb = optCb || noop;\n    data = getData(optData, token);\n  }\n\n  return {\n    cb: cb,\n    data: data,\n  };\n};\n\n\nmodule.exports.getData = getData;\nmodule.exports.getAPICallArgs = getAPICallArgs;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/transports/request.js":"/**\n * Simple transport using the node request library.\n */\n\nvar HttpsProxyAgent = require('https-proxy-agent');\nvar has = require('lodash').has;\nvar partial = require('lodash').partial;\nvar request = require('request');\n\n\nvar handleRequestTranportRes = function handleRequestTranportRes(cb, err, response, body) {\n  var headers;\n  var statusCode;\n\n  if (err) {\n    headers = response ? response.headers || {} : {};\n    statusCode = response ? response.statusCode || null : null;\n    cb(err, headers, statusCode, body);\n  } else {\n    cb(err, response.headers, response.statusCode, body);\n  }\n};\n\n\nvar getRequestTransportArgs = function getReqestTransportArgs(args) {\n  var transportArgs = {\n    url: args.url,\n    headers: args.headers,\n  };\n\n  if (has(args.data, 'file')) {\n    transportArgs.formData = args.data;\n  } else {\n    transportArgs.form = args.data;\n  }\n\n  return transportArgs;\n};\n\n\nvar proxiedRequestTransport = function proxiedRequestTransport(proxyURL) {\n  return function _proxiedRequestTransport(args, cb) {\n    var requestArgs = getRequestTransportArgs(args);\n    requestArgs.agent = new HttpsProxyAgent(proxyURL);\n    request.post(requestArgs, partial(handleRequestTranportRes, cb));\n  };\n};\n\n\nvar requestTransport = function requestTransport(args, cb) {\n  var requestArgs = getRequestTransportArgs(args);\n  request.post(requestArgs, partial(handleRequestTranportRes, cb));\n};\n\n\nmodule.exports.proxiedRequestTransport = proxiedRequestTransport;\nmodule.exports.requestTransport = requestTransport;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/index.js":"module.exports = {\n  ApiFacet: require('./api.js'),\n  AuthFacet: require('./auth.js'),\n  ChannelsFacet: require('./channels.js'),\n  ChatFacet: require('./chat.js'),\n  DmFacet: require('./dm.js'),\n  EmojiFacet: require('./emoji.js'),\n  FilesFacet: require('./files.js'),\n  GroupsFacet: require('./groups.js'),\n  OauthFacet: require('./oauth.js'),\n  PinsFacet: require('./pins.js'),\n  PresenceFacet: require('./presence.js'),\n  ReactionsFacet: require('./reactions.js'),\n  RtmFacet: require('./rtm.js'),\n  SearchFacet: require('./search.js'),\n  StarsFacet: require('./stars.js'),\n  TeamFacet: require('./team.js'),\n  UsersFacet: require('./users.js'),\n};\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/api.js":"/**\n * API Facet to make calls to methods in the api namespace.\n *\n * This provides functions to call:\n *   - test: {@link https://api.slack.com/methods/api.test|api.test}\n *\n */\n\n\nfunction ApiFacet(makeAPICall) {\n  this.name = 'api';\n  this.makeAPICall = makeAPICall;\n}\n\n\n/**\n * Checks API calling code.\n * @see {@link https://api.slack.com/methods/api.test|api.test}\n *\n * @param {Object=} opts\n * @param {?} opts.error Error response to return\n * @param {?} opts.foo example property to return\n * @param {function} optCb Optional callback, if not using promises.\n */\nApiFacet.prototype.test = function test(opts, optCb) {\n  var args = {\n    opts: opts,\n  };\n\n  return this.makeAPICall('api.test', args, optCb);\n};\n\n\nmodule.exports = ApiFacet;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/auth.js":"/**\n * API Facet to make calls to methods in the auth namespace.\n *\n * This provides functions to call:\n *   - test: {@link https://api.slack.com/methods/auth.test|auth.test}\n *\n */\n\n\nfunction AuthFacet(makeAPICall) {\n  this.name = 'auth';\n  this.makeAPICall = makeAPICall;\n}\n\n\n/**\n * Checks authentication & identity.\n * @see {@link https://api.slack.com/methods/auth.test|auth.test}\n *\n * @param {function} optCb Optional callback, if not using promises.\n */\nAuthFacet.prototype.test = function test(optCb) {\n  var args = {};\n\n  return this.makeAPICall('auth.test', args, optCb);\n};\n\n\nmodule.exports = AuthFacet;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/channels.js":"/**\n * API Facet to make calls to methods in the channels namespace.\n *\n * This provides functions to call:\n *   - archive: {@link https://api.slack.com/methods/channels.archive|channels.archive}\n *   - create: {@link https://api.slack.com/methods/channels.create|channels.create}\n *   - history: {@link https://api.slack.com/methods/channels.history|channels.history}\n *   - info: {@link https://api.slack.com/methods/channels.info|channels.info}\n *   - invite: {@link https://api.slack.com/methods/channels.invite|channels.invite}\n *   - join: {@link https://api.slack.com/methods/channels.join|channels.join}\n *   - kick: {@link https://api.slack.com/methods/channels.kick|channels.kick}\n *   - leave: {@link https://api.slack.com/methods/channels.leave|channels.leave}\n *   - list: {@link https://api.slack.com/methods/channels.list|channels.list}\n *   - mark: {@link https://api.slack.com/methods/channels.mark|channels.mark}\n *   - rename: {@link https://api.slack.com/methods/channels.rename|channels.rename}\n *   - setPurpose: {@link https://api.slack.com/methods/channels.setPurpose|channels.setPurpose}\n *   - setTopic: {@link https://api.slack.com/methods/channels.setTopic|channels.setTopic}\n *   - unarchive: {@link https://api.slack.com/methods/channels.unarchive|channels.unarchive}\n *\n */\n\nvar getArgsForFnsWithOptArgs = require('./helpers').getArgsForFnsWithOptArgs;\n\n\nfunction ChannelsFacet(makeAPICall) {\n  this.name = 'channels';\n  this.makeAPICall = makeAPICall;\n}\n\n\n/**\n * Archives a channel.\n * @see {@link https://api.slack.com/methods/channels.archive|channels.archive}\n *\n * @param {?} channel Channel to archive\n * @param {function} optCb Optional callback, if not using promises.\n */\nChannelsFacet.prototype.archive = function archive(channel, optCb) {\n  var args = {\n    channel: channel,\n  };\n\n  return this.makeAPICall('channels.archive', args, optCb);\n};\n\n/**\n * Creates a channel.\n * @see {@link https://api.slack.com/methods/channels.create|channels.create}\n *\n * @param {?} name Name of channel to create\n * @param {function} optCb Optional callback, if not using promises.\n */\nChannelsFacet.prototype.create = function create(name, optCb) {\n  var args = {\n    name: name,\n  };\n\n  return this.makeAPICall('channels.create', args, optCb);\n};\n\n/**\n * Fetches history of messages and events from a channel.\n * @see {@link https://api.slack.com/methods/channels.history|channels.history}\n *\n * @param {?} channel Channel to fetch history for.\n * @param {Object=} opts\n * @param {?} opts.latest End of time range of messages to include in results.\n * @param {?} opts.oldest Start of time range of messages to include in results.\n * @param {?} opts.inclusive Include messages with latest or oldest timestamp in results.\n * @param {?} opts.count Number of messages to return, between 1 and 1000.\n * @param {function} optCb Optional callback, if not using promises.\n */\nChannelsFacet.prototype.history = function history(channel, opts, optCb) {\n  var args = {\n    channel: channel,\n    opts: opts,\n  };\n\n  return this.makeAPICall('channels.history', args, optCb);\n};\n\n/**\n * Gets information about a channel.\n * @see {@link https://api.slack.com/methods/channels.info|channels.info}\n *\n * @param {?} channel Channel to get info on\n * @param {function} optCb Optional callback, if not using promises.\n */\nChannelsFacet.prototype.info = function info(channel, optCb) {\n  var args = {\n    channel: channel,\n  };\n\n  return this.makeAPICall('channels.info', args, optCb);\n};\n\n/**\n * Invites a user to a channel.\n * @see {@link https://api.slack.com/methods/channels.invite|channels.invite}\n *\n * @param {?} channel Channel to invite user to.\n * @param {?} user User to invite to channel.\n * @param {function} optCb Optional callback, if not using promises.\n */\nChannelsFacet.prototype.invite = function invite(channel, user, optCb) {\n  var args = {\n    channel: channel,\n    user: user,\n  };\n\n  return this.makeAPICall('channels.invite', args, optCb);\n};\n\n/**\n * Joins a channel, creating it if needed.\n * @see {@link https://api.slack.com/methods/channels.join|channels.join}\n *\n * @param {?} name Name of channel to join\n * @param {function} optCb Optional callback, if not using promises.\n */\nChannelsFacet.prototype.join = function join(name, optCb) {\n  var args = {\n    name: name,\n  };\n\n  return this.makeAPICall('channels.join', args, optCb);\n};\n\n/**\n * Removes a user from a channel.\n * @see {@link https://api.slack.com/methods/channels.kick|channels.kick}\n *\n * @param {?} channel Channel to remove user from.\n * @param {?} user User to remove from channel.\n * @param {function} optCb Optional callback, if not using promises.\n */\nChannelsFacet.prototype.kick = function kick(channel, user, optCb) {\n  var args = {\n    channel: channel,\n    user: user,\n  };\n\n  return this.makeAPICall('channels.kick', args, optCb);\n};\n\n/**\n * Leaves a channel.\n * @see {@link https://api.slack.com/methods/channels.leave|channels.leave}\n *\n * @param {?} channel Channel to leave\n * @param {function} optCb Optional callback, if not using promises.\n */\nChannelsFacet.prototype.leave = function leave(channel, optCb) {\n  var args = {\n    channel: channel,\n  };\n\n  return this.makeAPICall('channels.leave', args, optCb);\n};\n\n/**\n * Lists all channels in a Slack team.\n * @see {@link https://api.slack.com/methods/channels.list|channels.list}\n *\n * @param {?} optExcludeArchived Don't return archived channels.\n * @param {function} optCb Optional callback, if not using promises.\n */\nChannelsFacet.prototype.list = function list(optExcludeArchived, optCb) {\n  var fnArgs = getArgsForFnsWithOptArgs(optExcludeArchived, optCb, 'exclude_archived');\n  return this.makeAPICall('channels.list', fnArgs.args, fnArgs.cb);\n};\n\n/**\n * Sets the read cursor in a channel.\n * @see {@link https://api.slack.com/methods/channels.mark|channels.mark}\n *\n * @param {?} channel Channel to set reading cursor in.\n * @param {?} ts Timestamp of the most recently seen message.\n * @param {function} optCb Optional callback, if not using promises.\n */\nChannelsFacet.prototype.mark = function mark(channel, ts, optCb) {\n  var args = {\n    channel: channel,\n    ts: ts,\n  };\n\n  return this.makeAPICall('channels.mark', args, optCb);\n};\n\n/**\n * Renames a channel.\n * @see {@link https://api.slack.com/methods/channels.rename|channels.rename}\n *\n * @param {?} channel Channel to rename\n * @param {?} name New name for channel.\n * @param {function} optCb Optional callback, if not using promises.\n */\nChannelsFacet.prototype.rename = function rename(channel, name, optCb) {\n  var args = {\n    channel: channel,\n    name: name,\n  };\n\n  return this.makeAPICall('channels.rename', args, optCb);\n};\n\n/**\n * Sets the purpose for a channel.\n * @see {@link https://api.slack.com/methods/channels.setPurpose|channels.setPurpose}\n *\n * @param {?} channel Channel to set the purpose of\n * @param {?} purpose The new purpose\n * @param {function} optCb Optional callback, if not using promises.\n */\nChannelsFacet.prototype.setPurpose = function setPurpose(channel, purpose, optCb) {\n  var args = {\n    channel: channel,\n    purpose: purpose,\n  };\n\n  return this.makeAPICall('channels.setPurpose', args, optCb);\n};\n\n/**\n * Sets the topic for a channel.\n * @see {@link https://api.slack.com/methods/channels.setTopic|channels.setTopic}\n *\n * @param {?} channel Channel to set the topic of\n * @param {?} topic The new topic\n * @param {function} optCb Optional callback, if not using promises.\n */\nChannelsFacet.prototype.setTopic = function setTopic(channel, topic, optCb) {\n  var args = {\n    channel: channel,\n    topic: topic,\n  };\n\n  return this.makeAPICall('channels.setTopic', args, optCb);\n};\n\n/**\n * Unarchives a channel.\n * @see {@link https://api.slack.com/methods/channels.unarchive|channels.unarchive}\n *\n * @param {?} channel Channel to unarchive\n * @param {function} optCb Optional callback, if not using promises.\n */\nChannelsFacet.prototype.unarchive = function unarchive(channel, optCb) {\n  var args = {\n    channel: channel,\n  };\n\n  return this.makeAPICall('channels.unarchive', args, optCb);\n};\n\n\nmodule.exports = ChannelsFacet;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/helpers.js":"/**\n *\n */\n\nvar isFunction = require('lodash').isFunction;\nvar isNull = require('lodash').isNull;\nvar isUndefined = require('lodash').isUndefined;\n\n\nvar getArgsForFnsWithOptArgs = function getArgsForFnsWithOptArgs(optArg, optCb, optArgName) {\n  var ret = {\n    args: {},\n  };\n\n  if (isFunction(optCb)) {\n    ret.cb = optCb;\n    if (!isUndefined(optArg) && !isNull(optArg)) {\n      ret.args[optArgName] = optArg;\n    }\n  } else if (!isUndefined(optArg) && !isNull(optArg)) {\n    if (!isFunction(optArg)) {\n      ret.args[optArgName] = optArg;\n    } else {\n      ret.cb = optArg;\n    }\n  }\n\n  return ret;\n};\n\n\nmodule.exports.getArgsForFnsWithOptArgs = getArgsForFnsWithOptArgs;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/chat.js":"/**\n * API Facet to make calls to methods in the chat namespace.\n *\n * This provides functions to call:\n *   - delete: {@link https://api.slack.com/methods/chat.delete|chat.delete}\n *   - postMessage: {@link https://api.slack.com/methods/chat.postMessage|chat.postMessage}\n *   - update: {@link https://api.slack.com/methods/chat.update|chat.update}\n *\n */\n\n\nfunction ChatFacet(makeAPICall) {\n  this.name = 'chat';\n  this.makeAPICall = makeAPICall;\n}\n\n\n/**\n * Deletes a message.\n * @see {@link https://api.slack.com/methods/chat.delete|chat.delete}\n *\n * @param {?} ts Timestamp of the message to be deleted.\n * @param {?} channel Channel containing the message to be deleted.\n * @param {function} optCb Optional callback, if not using promises.\n */\nChatFacet.prototype.delete = function delete_(ts, channel, optCb) {\n  var args = {\n    ts: ts,\n    channel: channel,\n  };\n\n  return this.makeAPICall('chat.delete', args, optCb);\n};\n\n/**\n * Sends a message to a channel.\n * @see {@link https://api.slack.com/methods/chat.postMessage|chat.postMessage}\n *\n * @param {?} channel Channel, private group, or IM channel to send message to.\n *    Can be an encoded ID, or a name. See below for more details.\n * @param {?} text Text of the message to send. See below for an explanation of formatting.\n * @param {Object=} opts\n * @param {?} opts.username Name of bot.\n * @param {?} opts.as_user Pass true to post the message as the authed user, instead of as a bot\n * @param {?} opts.parse Change how messages are treated. See below.\n * @param {?} opts.link_names Find and link channel names and usernames.\n * @param {?} opts.attachments Structured message attachments.\n * @param {?} opts.unfurl_links Pass true to enable unfurling of primarily text-based content.\n * @param {?} opts.unfurl_media Pass false to disable unfurling of media content.\n * @param {?} opts.icon_url URL to an image to use as the icon for this message\n * @param {?} opts.icon_emoji emoji to use as the icon for this message. Overrides `icon_url`.\n * @param {function} optCb Optional callback, if not using promises.\n */\nChatFacet.prototype.postMessage = function postMessage(channel, text, opts, optCb) {\n  var args = {\n    channel: channel,\n    text: text,\n    opts: opts,\n  };\n\n  return this.makeAPICall('chat.postMessage', args, optCb);\n};\n\n/**\n * Updates a message.\n * @see {@link https://api.slack.com/methods/chat.update|chat.update}\n *\n * @param {?} ts Timestamp of the message to be updated.\n * @param {?} channel Channel containing the message to be updated.\n * @param {?} text New text for the message, using the [default formatting rules](/docs/formatting).\n * @param {Object=} opts\n * @param {?} opts.attachments Structured message attachments.\n * @param {?} opts.parse Change how messages are treated. See below.\n * @param {?} opts.link_names Find and link channel names and usernames.\n * @param {function} optCb Optional callback, if not using promises.\n */\nChatFacet.prototype.update = function update(ts, channel, text, opts, optCb) {\n  var args = {\n    ts: ts,\n    channel: channel,\n    text: text,\n    opts: opts,\n  };\n\n  return this.makeAPICall('chat.update', args, optCb);\n};\n\n\nmodule.exports = ChatFacet;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/dm.js":"/**\n * API Facet to make calls to methods in the im namespace.\n *\n * This provides functions to call:\n *   - close: {@link https://api.slack.com/methods/im.close|im.close}\n *   - history: {@link https://api.slack.com/methods/im.history|im.history}\n *   - list: {@link https://api.slack.com/methods/im.list|im.list}\n *   - mark: {@link https://api.slack.com/methods/im.mark|im.mark}\n *   - open: {@link https://api.slack.com/methods/im.open|im.open}\n *\n */\n\nfunction DmFacet(makeAPICall) {\n  this.name = 'dm';\n  this.makeAPICall = makeAPICall;\n}\n\n\n/**\n * Close a direct message channel.\n * @see {@link https://api.slack.com/methods/im.close|im.close}\n *\n * @param {?} channel Direct message channel to close.\n * @param {function} optCb Optional callback, if not using promises.\n */\nDmFacet.prototype.close = function close(channel, optCb) {\n  var args = {\n    channel: channel,\n  };\n\n  return this.makeAPICall('im.close', args, optCb);\n};\n\n/**\n * Fetches history of messages and events from direct message channel.\n * @see {@link https://api.slack.com/methods/im.history|im.history}\n *\n * @param {?} channel Direct message channel to fetch history for.\n * @param {Object=} opts\n * @param {?} opts.latest End of time range of messages to include in results.\n * @param {?} opts.oldest Start of time range of messages to include in results.\n * @param {?} opts.inclusive Include messages with latest or oldest timestamp in results.\n * @param {?} opts.count Number of messages to return, between 1 and 1000.\n * @param {function} optCb Optional callback, if not using promises.\n */\nDmFacet.prototype.history = function history(channel, opts, optCb) {\n  var args = {\n    channel: channel,\n    opts: opts,\n  };\n\n  return this.makeAPICall('im.history', args, optCb);\n};\n\n/**\n * Lists direct message channels for the calling user.\n * @see {@link https://api.slack.com/methods/im.list|im.list}\n * @param {function} optCb Optional callback, if not using promises.\n */\nDmFacet.prototype.list = function list(optCb) {\n  var args = {};\n\n  return this.makeAPICall('im.list', args, optCb);\n};\n\n/**\n * Sets the read cursor in a direct message channel.\n * @see {@link https://api.slack.com/methods/im.mark|im.mark}\n *\n * @param {?} channel Direct message channel to set reading cursor in.\n * @param {?} ts Timestamp of the most recently seen message.\n * @param {function} optCb Optional callback, if not using promises.\n */\nDmFacet.prototype.mark = function mark(channel, ts, optCb) {\n  var args = {\n    channel: channel,\n    ts: ts,\n  };\n\n  return this.makeAPICall('im.mark', args, optCb);\n};\n\n/**\n * Opens a direct message channel.\n * @see {@link https://api.slack.com/methods/im.open|im.open}\n *\n * @param {?} user User to open a direct message channel with.\n * @param {function} optCb Optional callback, if not using promises.\n */\nDmFacet.prototype.open = function open(user, optCb) {\n  var args = {\n    user: user,\n  };\n\n  return this.makeAPICall('im.open', args, optCb);\n};\n\n\nmodule.exports = DmFacet;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/emoji.js":"/**\n * API Facet to make calls to methods in the emoji namespace.\n *\n * This provides functions to call:\n *   - list: {@link https://api.slack.com/methods/emoji.list|emoji.list}\n *\n */\n\n\nfunction EmojiFacet(makeAPICall) {\n  this.name = 'emoji';\n  this.makeAPICall = makeAPICall;\n}\n\n\n/**\n * Lists custom emoji for a team.\n * @see {@link https://api.slack.com/methods/emoji.list|emoji.list}\n *\n * @param {function} optCb Optional callback, if not using promises.\n */\nEmojiFacet.prototype.list = function list(optCb) {\n  var args = {};\n\n  return this.makeAPICall('emoji.list', args, optCb);\n};\n\n\nmodule.exports = EmojiFacet;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/files.js":"/**\n * API Facet to make calls to methods in the files namespace.\n *\n * This provides functions to call:\n *   - delete: {@link https://api.slack.com/methods/files.delete|files.delete}\n *   - info: {@link https://api.slack.com/methods/files.info|files.info}\n *   - list: {@link https://api.slack.com/methods/files.list|files.list}\n *   - upload: {@link https://api.slack.com/methods/files.upload|files.upload}\n *\n */\n\n\nfunction FilesFacet(makeAPICall) {\n  this.name = 'files';\n  this.makeAPICall = makeAPICall;\n}\n\n\n/**\n * Deletes a file.\n * @see {@link https://api.slack.com/methods/files.delete|files.delete}\n *\n * @param {?} file ID of file to delete.\n * @param {function} optCb Optional callback, if not using promises.\n */\nFilesFacet.prototype.delete = function delete_(file, optCb) {\n  var args = {\n    file: file,\n  };\n\n  return this.makeAPICall('files.delete', args, optCb);\n};\n\n/**\n * Gets information about a team file.\n * @see {@link https://api.slack.com/methods/files.info|files.info}\n *\n * @param {?} file File to fetch info for\n * @param {function} optCb Optional callback, if not using promises.\n */\nFilesFacet.prototype.info = function info(file, optCb) {\n  var args = {\n    file: file,\n  };\n\n  return this.makeAPICall('files.info', args, optCb);\n};\n\n/**\n * Lists & filters team files.\n * @see {@link https://api.slack.com/methods/files.list|files.list}\n *\n * @param {Object=} opts\n * @param {?} opts.user Filter files created by a single user.\n * @param {?} opts.ts_from Filter files created after this timestamp (inclusive).\n * @param {?} opts.ts_to Filter files created before this timestamp (inclusive).\n * @param {?} opts.types Filter files by type:\n   - `all` - All files\n   - `posts` - Posts\n   - `snippets` - Snippets\n   - `images` - Image files\n   - `gdocs` - Google docs\n   - `zips` - Zip files\n   - `pdfs` - PDF files\n\n * You can pass multiple values in the types argument, like `types=posts,snippets`.\n * The default value is `all`, which does not filter the list.\n *\n * @param {function} optCb Optional callback, if not using promises.\n */\nFilesFacet.prototype.list = function list(opts, optCb) {\n  var args = {\n    opts: opts,\n  };\n\n  return this.makeAPICall('files.list', args, optCb);\n};\n\n/**\n * Uploads or creates a file.\n * @see {@link https://api.slack.com/methods/files.upload|files.upload}\n *\n * @param {Object=} opts\n * @param {?} opts.file File contents via `multipart/form-data`.\n * @param {?} opts.content File contents via a POST var.\n * @param {?} opts.filetype Slack-internal file type identifier.\n * @param {?} opts.filename Filename of file.\n * @param {?} opts.title Title of file.\n * @param {?} opts.initial_comment Initial comment to add to file.\n * @param {?} opts.channels Comma separated list of channels to share the file into.\n * @param {function} optCb Optional callback, if not using promises.\n */\nFilesFacet.prototype.upload = function upload(opts, optCb) {\n  var args = {\n    opts: opts,\n  };\n\n  return this.makeAPICall('files.upload', args, optCb);\n};\n\n\nmodule.exports = FilesFacet;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/groups.js":"/**\n * API Facet to make calls to methods in the groups namespace.\n *\n * This provides functions to call:\n *   - archive: {@link https://api.slack.com/methods/groups.archive|groups.archive}\n *   - close: {@link https://api.slack.com/methods/groups.close|groups.close}\n *   - create: {@link https://api.slack.com/methods/groups.create|groups.create}\n *   - createChild: {@link https://api.slack.com/methods/groups.createChild|groups.createChild}\n *   - history: {@link https://api.slack.com/methods/groups.history|groups.history}\n *   - info: {@link https://api.slack.com/methods/groups.info|groups.info}\n *   - invite: {@link https://api.slack.com/methods/groups.invite|groups.invite}\n *   - kick: {@link https://api.slack.com/methods/groups.kick|groups.kick}\n *   - leave: {@link https://api.slack.com/methods/groups.leave|groups.leave}\n *   - list: {@link https://api.slack.com/methods/groups.list|groups.list}\n *   - mark: {@link https://api.slack.com/methods/groups.mark|groups.mark}\n *   - open: {@link https://api.slack.com/methods/groups.open|groups.open}\n *   - rename: {@link https://api.slack.com/methods/groups.rename|groups.rename}\n *   - setPurpose: {@link https://api.slack.com/methods/groups.setPurpose|groups.setPurpose}\n *   - setTopic: {@link https://api.slack.com/methods/groups.setTopic|groups.setTopic}\n *   - unarchive: {@link https://api.slack.com/methods/groups.unarchive|groups.unarchive}\n *\n */\n\nvar getArgsForFnsWithOptArgs = require('./helpers').getArgsForFnsWithOptArgs;\n\n\nfunction GroupsFacet(makeAPICall) {\n  this.name = 'groups';\n  this.makeAPICall = makeAPICall;\n}\n\n\n/**\n * Archives a private group.\n * @see {@link https://api.slack.com/methods/groups.archive|groups.archive}\n *\n * @param {?} channel Private group to archive\n * @param {function} optCb Optional callback, if not using promises.\n */\nGroupsFacet.prototype.archive = function archive(channel, optCb) {\n  var args = {\n    channel: channel,\n  };\n\n  return this.makeAPICall('groups.archive', args, optCb);\n};\n\n/**\n * Closes a private group.\n * @see {@link https://api.slack.com/methods/groups.close|groups.close}\n *\n * @param {?} channel Group to open.\n * @param {function} optCb Optional callback, if not using promises.\n */\nGroupsFacet.prototype.close = function close(channel, optCb) {\n  var args = {\n    channel: channel,\n  };\n\n  return this.makeAPICall('groups.close', args, optCb);\n};\n\n/**\n * Creates a private group.\n * @see {@link https://api.slack.com/methods/groups.create|groups.create}\n *\n * @param {?} name Name of group to create\n * @param {function} optCb Optional callback, if not using promises.\n */\nGroupsFacet.prototype.create = function create(name, optCb) {\n  var args = {\n    name: name,\n  };\n\n  return this.makeAPICall('groups.create', args, optCb);\n};\n\n/**\n * Clones and archives a private group.\n * @see {@link https://api.slack.com/methods/groups.createChild|groups.createChild}\n *\n * @param {?} channel Group to clone and archive.\n * @param {function} optCb Optional callback, if not using promises.\n */\nGroupsFacet.prototype.createChild = function createChild(channel, optCb) {\n  var args = {\n    channel: channel,\n  };\n\n  return this.makeAPICall('groups.createChild', args, optCb);\n};\n\n/**\n * Fetches history of messages and events from a private group.\n * @see {@link https://api.slack.com/methods/groups.history|groups.history}\n *\n * @param {?} channel Group to fetch history for.\n * @param {Object=} opts\n * @param {?} opts.latest End of time range of messages to include in results.\n * @param {?} opts.oldest Start of time range of messages to include in results.\n * @param {?} opts.inclusive Include messages with latest or oldest timestamp in results.\n * @param {?} opts.count Number of messages to return, between 1 and 1000.\n * @param {function} optCb Optional callback, if not using promises.\n */\nGroupsFacet.prototype.history = function history(channel, opts, optCb) {\n  var args = {\n    channel: channel,\n    opts: opts,\n  };\n\n  return this.makeAPICall('groups.history', args, optCb);\n};\n\n/**\n * Gets information about a private group.\n * @see {@link https://api.slack.com/methods/groups.info|groups.info}\n *\n * @param {?} channel Group to get info on\n * @param {function} optCb Optional callback, if not using promises.\n */\nGroupsFacet.prototype.info = function info(channel, optCb) {\n  var args = {\n    channel: channel,\n  };\n\n  return this.makeAPICall('groups.info', args, optCb);\n};\n\n/**\n * Invites a user to a private group.\n * @see {@link https://api.slack.com/methods/groups.invite|groups.invite}\n *\n * @param {?} channel Private group to invite user to.\n * @param {?} user User to invite.\n * @param {function} optCb Optional callback, if not using promises.\n */\nGroupsFacet.prototype.invite = function invite(channel, user, optCb) {\n  var args = {\n    channel: channel,\n    user: user,\n  };\n\n  return this.makeAPICall('groups.invite', args, optCb);\n};\n\n/**\n * Removes a user from a private group.\n * @see {@link https://api.slack.com/methods/groups.kick|groups.kick}\n *\n * @param {?} channel Group to remove user from.\n * @param {?} user User to remove from group.\n * @param {function} optCb Optional callback, if not using promises.\n */\nGroupsFacet.prototype.kick = function kick(channel, user, optCb) {\n  var args = {\n    channel: channel,\n    user: user,\n  };\n\n  return this.makeAPICall('groups.kick', args, optCb);\n};\n\n/**\n * Leaves a private group.\n * @see {@link https://api.slack.com/methods/groups.leave|groups.leave}\n *\n * @param {?} channel Group to leave\n * @param {function} optCb Optional callback, if not using promises.\n */\nGroupsFacet.prototype.leave = function leave(channel, optCb) {\n  var args = {\n    channel: channel,\n  };\n\n  return this.makeAPICall('groups.leave', args, optCb);\n};\n\n/**\n * Lists private groups that the calling user has access to.\n * @see {@link https://api.slack.com/methods/groups.list|groups.list}\n *\n * @param {?} optExcludeArchived Don't return archived groups.\n * @param {function} optCb Optional callback, if not using promises.\n */\nGroupsFacet.prototype.list = function list(optExcludeArchived, optCb) {\n  var fnArgs = getArgsForFnsWithOptArgs(optExcludeArchived, optCb, 'exclude_archived');\n  return this.makeAPICall('groups.list', fnArgs.args, fnArgs.cb);\n};\n\n/**\n * Sets the read cursor in a private group.\n * @see {@link https://api.slack.com/methods/groups.mark|groups.mark}\n *\n * @param {?} channel Group to set reading cursor in.\n * @param {?} ts Timestamp of the most recently seen message.\n * @param {function} optCb Optional callback, if not using promises.\n */\nGroupsFacet.prototype.mark = function mark(channel, ts, optCb) {\n  var args = {\n    channel: channel,\n    ts: ts,\n  };\n\n  return this.makeAPICall('groups.mark', args, optCb);\n};\n\n/**\n * Opens a private group.\n * @see {@link https://api.slack.com/methods/groups.open|groups.open}\n *\n * @param {?} channel Group to open.\n * @param {function} optCb Optional callback, if not using promises.\n */\nGroupsFacet.prototype.open = function open(channel, optCb) {\n  var args = {\n    channel: channel,\n  };\n\n  return this.makeAPICall('groups.open', args, optCb);\n};\n\n/**\n * Renames a private group.\n * @see {@link https://api.slack.com/methods/groups.rename|groups.rename}\n *\n * @param {?} channel Group to rename\n * @param {?} name New name for group.\n * @param {function} optCb Optional callback, if not using promises.\n */\nGroupsFacet.prototype.rename = function rename(channel, name, optCb) {\n  var args = {\n    channel: channel,\n    name: name,\n  };\n\n  return this.makeAPICall('groups.rename', args, optCb);\n};\n\n/**\n * Sets the purpose for a private group.\n * @see {@link https://api.slack.com/methods/groups.setPurpose|groups.setPurpose}\n *\n * @param {?} channel Private group to set the purpose of\n * @param {?} purpose The new purpose\n * @param {function} optCb Optional callback, if not using promises.\n */\nGroupsFacet.prototype.setPurpose = function setPurpose(channel, purpose, optCb) {\n  var args = {\n    channel: channel,\n    purpose: purpose,\n  };\n\n  return this.makeAPICall('groups.setPurpose', args, optCb);\n};\n\n/**\n * Sets the topic for a private group.\n * @see {@link https://api.slack.com/methods/groups.setTopic|groups.setTopic}\n *\n * @param {?} channel Private group to set the topic of\n * @param {?} topic The new topic\n * @param {function} optCb Optional callback, if not using promises.\n */\nGroupsFacet.prototype.setTopic = function setTopic(channel, topic, optCb) {\n  var args = {\n    channel: channel,\n    topic: topic,\n  };\n\n  return this.makeAPICall('groups.setTopic', args, optCb);\n};\n\n/**\n * Unarchives a private group.\n * @see {@link https://api.slack.com/methods/groups.unarchive|groups.unarchive}\n *\n * @param {?} channel Group to unarchive\n * @param {function} optCb Optional callback, if not using promises.\n */\nGroupsFacet.prototype.unarchive = function unarchive(channel, optCb) {\n  var args = {\n    channel: channel,\n  };\n\n  return this.makeAPICall('groups.unarchive', args, optCb);\n};\n\n\nmodule.exports = GroupsFacet;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/oauth.js":"/**\n * API Facet to make calls to methods in the oauth namespace.\n *\n * This provides functions to call:\n *   - access: {@link https://api.slack.com/methods/oauth.access|oauth.access}\n *\n */\n\n\nfunction OauthFacet(makeAPICall) {\n  this.name = 'oauth';\n  this.makeAPICall = makeAPICall;\n}\n\n\n/**\n * Exchanges a temporary OAuth code for an API token.\n * @see {@link https://api.slack.com/methods/oauth.access|oauth.access}\n *\n * @param {?} clientId Issued when you created your application.\n * @param {?} clientSecret Issued when you created your application.\n * @param {?} code The `code` param returned via the OAuth callback.\n * @param {Object=} opts\n * @param {?} opts.redirect_uri This must match the originally submitted URI (if one was sent).\n * @param {function} optCb Optional callback, if not using promises.\n */\nOauthFacet.prototype.access = function access(clientId, clientSecret, code, opts, optCb) {\n  var args = {\n    client_id: clientId,\n    client_secret: clientSecret,\n    code: code,\n    opts: opts,\n  };\n\n  return this.makeAPICall('oauth.access', args, optCb);\n};\n\n\nmodule.exports = OauthFacet;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/pins.js":"/**\n * API Facet to make calls to methods in the pins namespace.\n *\n * This provides functions to call:\n *   - add: {@link https://api.slack.com/methods/pins.add|pins.add}\n *   - list: {@link https://api.slack.com/methods/pins.list|pins.list}\n *   - remove: {@link https://api.slack.com/methods/pins.remove|pins.remove}\n *\n */\n\n\nfunction PinsFacet(makeAPICall) {\n  this.name = 'pins';\n  this.makeAPICall = makeAPICall;\n}\n\n\n/**\n * Pins an item to a channel.\n * @see {@link https://api.slack.com/methods/pins.add|pins.add}\n *\n * @param {?} channel Channel to pin the item in.\n * @param {Object=} opts\n * @param {?} opts.file File to pin.\n * @param {?} opts.file_comment File comment to pin.\n * @param {?} opts.timestamp Timestamp of the message to pin.\n * @param {function} optCb Optional callback, if not using promises.\n */\nPinsFacet.prototype.add = function add(channel, opts, optCb) {\n  var args = {\n    channel: channel,\n    opts: opts,\n  };\n\n  return this.makeAPICall('pins.add', args, optCb);\n};\n\n/**\n * Lists items pinned to a channel.\n * @see {@link https://api.slack.com/methods/pins.list|pins.list}\n *\n * @param {?} channel Channel to get pinned items for.\n * @param {function} optCb Optional callback, if not using promises.\n */\nPinsFacet.prototype.list = function list(channel, optCb) {\n  var args = {\n    channel: channel,\n  };\n\n  return this.makeAPICall('pins.list', args, optCb);\n};\n\n/**\n * Un-pins an item from a channel.\n * @see {@link https://api.slack.com/methods/pins.remove|pins.remove}\n *\n * @param {?} channel Channel where the item is pinned to.\n * @param {Object=} opts\n * @param {?} opts.file File to un-pin.\n * @param {?} opts.file_comment File comment to un-pin.\n * @param {?} opts.timestamp Timestamp of the message to un-pin.\n * @param {function} optCb Optional callback, if not using promises.\n */\nPinsFacet.prototype.remove = function remove(channel, opts, optCb) {\n  var args = {\n    channel: channel,\n    opts: opts,\n  };\n\n  return this.makeAPICall('pins.remove', args, optCb);\n};\n\n\nmodule.exports = PinsFacet;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/presence.js":"/**\n * API Facet to make calls to methods in the presence namespace.\n *\n * This provides functions to call:\n *   - set: {@link https://api.slack.com/methods/presence.set|presence.set}\n *\n */\n\n\nfunction PresenceFacet(makeAPICall) {\n  this.name = 'presence';\n  this.makeAPICall = makeAPICall;\n}\n\n\n/**\n * Manually set user presence\n * @see {@link https://api.slack.com/methods/presence.set|presence.set}\n *\n * @param {?} presence Either `active` or `away`\n * @param {function} optCb Optional callback, if not using promises.\n */\nPresenceFacet.prototype.set = function set(presence, optCb) {\n  var args = {\n    presence: presence,\n  };\n\n  return this.makeAPICall('presence.set', args, optCb);\n};\n\n\nmodule.exports = PresenceFacet;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/reactions.js":"/**\n * API Facet to make calls to methods in the reactions namespace.\n *\n * This provides functions to call:\n *   - add: {@link https://api.slack.com/methods/reactions.add|reactions.add}\n *   - get: {@link https://api.slack.com/methods/reactions.get|reactions.get}\n *   - list: {@link https://api.slack.com/methods/reactions.list|reactions.list}\n *   - remove: {@link https://api.slack.com/methods/reactions.remove|reactions.remove}\n *\n */\n\n\nfunction ReactionsFacet(makeAPICall) {\n  this.name = 'reactions';\n  this.makeAPICall = makeAPICall;\n}\n\n\n/**\n * Adds a reaction to an item.\n * @see {@link https://api.slack.com/methods/reactions.add|reactions.add}\n *\n * @param {?} name Reaction (emoji) name.\n * @param {Object=} opts\n * @param {?} opts.file File to add reaction to.\n * @param {?} opts.file_comment File comment to add reaction to.\n * @param {?} opts.channel Channel where the message to add reaction to was posted.\n * @param {?} opts.timestamp Timestamp of the message to add reaction to.\n * @param {function} optCb Optional callback, if not using promises.\n */\nReactionsFacet.prototype.add = function add(name, opts, optCb) {\n  var args = {\n    name: name,\n    opts: opts,\n  };\n\n  return this.makeAPICall('reactions.add', args, optCb);\n};\n\n/**\n * Gets reactions for an item.\n * @see {@link https://api.slack.com/methods/reactions.get|reactions.get}\n *\n * @param {Object=} opts\n * @param {?} opts.file File to get reactions for.\n * @param {?} opts.file_comment File comment to get reactions for.\n * @param {?} opts.channel Channel where the message to get reactions for was posted.\n * @param {?} opts.timestamp Timestamp of the message to get reactions for.\n * @param {?} opts.full If true always return the complete reaction list.\n * @param {function} optCb Optional callback, if not using promises.\n */\nReactionsFacet.prototype.get = function get(opts, optCb) {\n  var args = {\n    opts: opts,\n  };\n\n  return this.makeAPICall('reactions.get', args, optCb);\n};\n\n/**\n * Lists reactions made by a user.\n * @see {@link https://api.slack.com/methods/reactions.list|reactions.list}\n *\n * @param {Object=} opts\n * @param {?} opts.user Show reactions made by this user. Defaults to the authed user.\n * @param {?} opts.full If true always return the complete reaction list.\n * @param {function} optCb Optional callback, if not using promises.\n */\nReactionsFacet.prototype.list = function list(opts, optCb) {\n  var args = {\n    opts: opts,\n  };\n\n  return this.makeAPICall('reactions.list', args, optCb);\n};\n\n/**\n * Removes a reaction from an item.\n * @see {@link https://api.slack.com/methods/reactions.remove|reactions.remove}\n *\n * @param {?} name Reaction (emoji) name.\n * @param {Object=} opts\n * @param {?} opts.file File to remove reaction from.\n * @param {?} opts.file_comment File comment to remove reaction from.\n * @param {?} opts.channel Channel where the message to remove reaction from was posted.\n * @param {?} opts.timestamp Timestamp of the message to remove reaction from.\n * @param {function} optCb Optional callback, if not using promises.\n */\nReactionsFacet.prototype.remove = function remove(name, opts, optCb) {\n  var args = {\n    name: name,\n    opts: opts,\n  };\n\n  return this.makeAPICall('reactions.remove', args, optCb);\n};\n\n\nmodule.exports = ReactionsFacet;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/rtm.js":"/**\n * API Facet to make calls to methods in the rtm namespace.\n *\n * This provides functions to call:\n *   - start: {@link https://api.slack.com/methods/rtm.start|rtm.start}\n *\n */\n\n\nfunction RtmFacet(makeAPICall) {\n  this.name = 'rtm';\n  this.makeAPICall = makeAPICall;\n}\n\n\n/**\n * Starts a Real Time Messaging session.\n * @see {@link https://api.slack.com/methods/rtm.start|rtm.start}\n *\n * @param {Object=} opts\n * @param {?} opts.simple_latest Return timestamp only for latest message object of each channel\n *     (improves performance).\n * @param {?} opts.no_unreads Skip unread counts for each channel (improves performance).\n * @param {function} optCb Optional callback, if not using promises.\n */\nRtmFacet.prototype.start = function start(opts, optCb) {\n  var args = {\n    opts: opts,\n  };\n\n  return this.makeAPICall('rtm.start', args, optCb);\n};\n\n\nmodule.exports = RtmFacet;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/search.js":"/**\n * API Facet to make calls to methods in the search namespace.\n *\n * This provides functions to call:\n *   - all: {@link https://api.slack.com/methods/search.all|search.all}\n *   - files: {@link https://api.slack.com/methods/search.files|search.files}\n *   - messages: {@link https://api.slack.com/methods/search.messages|search.messages}\n *\n */\n\n\nfunction SearchFacet(makeAPICall) {\n  this.name = 'search';\n  this.makeAPICall = makeAPICall;\n}\n\n\n/**\n * Searches for messages and files matching a query.\n * @see {@link https://api.slack.com/methods/search.all|search.all}\n *\n * @param {?} query Search query. May contains booleans, etc.\n * @param {Object=} opts\n * @param {?} opts.sort Return matches sorted by either `score` or `timestamp`.\n * @param {?} opts.sort_dir Change sort direction to ascending (`asc`) or descending (`desc`).\n * @param {?} opts.highlight Pass a value of `1` to enable query highlight markers (see below).\n * @param {function} optCb Optional callback, if not using promises.\n */\nSearchFacet.prototype.all = function all(query, opts, optCb) {\n  var args = {\n    query: query,\n    opts: opts,\n  };\n\n  return this.makeAPICall('search.all', args, optCb);\n};\n\n/**\n * Searches for files matching a query.\n * @see {@link https://api.slack.com/methods/search.files|search.files}\n *\n * @param {?} query Search query. May contain booleans, etc.\n * @param {Object=} opts\n * @param {?} opts.sort Return matches sorted by either `score` or `timestamp`.\n * @param {?} opts.sort_dir Change sort direction to ascending (`asc`) or descending (`desc`).\n * @param {?} opts.highlight Pass a value of `1` to enable query highlight markers (see below).\n * @param {function} optCb Optional callback, if not using promises.\n */\nSearchFacet.prototype.files = function files(query, opts, optCb) {\n  var args = {\n    query: query,\n    opts: opts,\n  };\n\n  return this.makeAPICall('search.files', args, optCb);\n};\n\n/**\n * Searches for messages matching a query.\n * @see {@link https://api.slack.com/methods/search.messages|search.messages}\n *\n * @param {?} query Search query. May contains booleans, etc.\n * @param {Object=} opts\n * @param {?} opts.sort Return matches sorted by either `score` or `timestamp`.\n * @param {?} opts.sort_dir Change sort direction to ascending (`asc`) or descending (`desc`).\n * @param {?} opts.highlight Pass a value of `1` to enable query highlight markers (see below).\n * @param {function} optCb Optional callback, if not using promises.\n */\nSearchFacet.prototype.messages = function messages(query, opts, optCb) {\n  var args = {\n    query: query,\n    opts: opts,\n  };\n\n  return this.makeAPICall('search.messages', args, optCb);\n};\n\n\nmodule.exports = SearchFacet;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/stars.js":"/**\n * API Facet to make calls to methods in the stars namespace.\n *\n * This provides functions to call:\n *   - add: {@link https://api.slack.com/methods/stars.add|stars.add}\n *   - list: {@link https://api.slack.com/methods/stars.list|stars.list}\n *   - remove: {@link https://api.slack.com/methods/stars.remove|stars.remove}\n *\n */\n\nvar getArgsForFnsWithOptArgs = require('./helpers').getArgsForFnsWithOptArgs;\n\n\nfunction StarsFacet(makeAPICall) {\n  this.name = 'stars';\n  this.makeAPICall = makeAPICall;\n}\n\n\n/**\n * Adds a star to an item.\n * @see {@link https://api.slack.com/methods/stars.add|stars.add}\n *\n * @param {Object=} opts\n * @param {?} opts.file File to add star to.\n * @param {?} opts.file_comment File comment to add star to.\n * @param {?} opts.channel Channel to add star to, or channel where the message to add star to was\n *     posted (used with `timestamp`).\n * @param {?} opts.timestamp Timestamp of the message to add star to.\n * @param {function} optCb Optional callback, if not using promises.\n */\nStarsFacet.prototype.add = function add(opts, optCb) {\n  var args = {\n    opts: opts,\n  };\n\n  return this.makeAPICall('stars.add', args, optCb);\n};\n\n/**\n * Lists stars for a user.\n * @see {@link https://api.slack.com/methods/stars.list|stars.list}\n *\n * @param {?} optUser Show stars by this user. Defaults to the authed user.\n * @param {function} optCb Optional callback, if not using promises.\n */\nStarsFacet.prototype.list = function list(optUser, optCb) {\n  var fnArgs = getArgsForFnsWithOptArgs(optUser, optCb, 'user');\n  return this.makeAPICall('stars.list', fnArgs.args, fnArgs.cb);\n};\n\n/**\n * Removes a star from an item.\n * @see {@link https://api.slack.com/methods/stars.remove|stars.remove}\n *\n * @param {Object=} opts\n * @param {?} opts.file File to remove star from.\n * @param {?} opts.file_comment File comment to remove star from.\n * @param {?} opts.channel Channel to remove star from, or channel where the message to remove star\n *     from was posted (used with `timestamp`).\n * @param {?} opts.timestamp Timestamp of the message to remove star from.\n * @param {function} optCb Optional callback, if not using promises.\n */\nStarsFacet.prototype.remove = function remove(opts, optCb) {\n  var args = {\n    opts: opts,\n  };\n\n  return this.makeAPICall('stars.remove', args, optCb);\n};\n\n\nmodule.exports = StarsFacet;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/team.js":"/**\n * API Facet to make calls to methods in the team namespace.\n *\n * This provides functions to call:\n *   - accessLogs: {@link https://api.slack.com/methods/team.accessLogs|team.accessLogs}\n *   - info: {@link https://api.slack.com/methods/team.info|team.info}\n *\n */\n\n\nfunction TeamFacet(makeAPICall) {\n  this.name = 'team';\n  this.makeAPICall = makeAPICall;\n}\n\n\n/**\n * Gets the access logs for the current team.\n * @see {@link https://api.slack.com/methods/team.accessLogs|team.accessLogs}\n *\n * @param {function} optCb Optional callback, if not using promises.\n */\nTeamFacet.prototype.accessLogs = function accessLogs(optCb) {\n  var args = {};\n\n  return this.makeAPICall('team.accessLogs', args, optCb);\n};\n\n/**\n * Gets information about the current team.\n * @see {@link https://api.slack.com/methods/team.info|team.info}\n *\n * @param {function} optCb Optional callback, if not using promises.\n */\nTeamFacet.prototype.info = function info(optCb) {\n  var args = {};\n\n  return this.makeAPICall('team.info', args, optCb);\n};\n\n\nmodule.exports = TeamFacet;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/web/facets/users.js":"/**\n * API Facet to make calls to methods in the users namespace.\n *\n * This provides functions to call:\n *   - getPresence: {@link https://api.slack.com/methods/users.getPresence|users.getPresence}\n *   - info: {@link https://api.slack.com/methods/users.info|users.info}\n *   - list: {@link https://api.slack.com/methods/users.list|users.list}\n *   - setActive: {@link https://api.slack.com/methods/users.setActive|users.setActive}\n *   - setPresence: {@link https://api.slack.com/methods/users.setPresence|users.setPresence}\n *\n */\n\nvar getArgsForFnsWithOptArgs = require('./helpers').getArgsForFnsWithOptArgs;\n\n\nfunction UsersFacet(makeAPICall) {\n  this.name = 'users';\n  this.makeAPICall = makeAPICall;\n}\n\n\n/**\n * Gets user presence information.\n * @see {@link https://api.slack.com/methods/users.getPresence|users.getPresence}\n *\n * @param {?} user User to get presence info on. Defaults to the authed user.\n * @param {function} optCb Optional callback, if not using promises.\n */\nUsersFacet.prototype.getPresence = function getPresence(user, optCb) {\n  var args = {\n    user: user,\n  };\n\n  return this.makeAPICall('users.getPresence', args, optCb);\n};\n\n/**\n * Gets information about a user.\n * @see {@link https://api.slack.com/methods/users.info|users.info}\n *\n * @param {?} user User to get info on\n * @param {function} optCb Optional callback, if not using promises.\n */\nUsersFacet.prototype.info = function info(user, optCb) {\n  var args = {\n    user: user,\n  };\n\n  return this.makeAPICall('users.info', args, optCb);\n};\n\n/**\n * Lists all users in a Slack team.\n * @see {@link https://api.slack.com/methods/users.list|users.list}\n *\n * @param {?} optPresence Whether to include presence data in the output\n * @param {function} optCb Optional callback, if not using promises.\n */\nUsersFacet.prototype.list = function list(optPresence, optCb) {\n  var fnArgs = getArgsForFnsWithOptArgs(optPresence, optCb, 'presence');\n  return this.makeAPICall('users.list', fnArgs.args, fnArgs.cb);\n};\n\n/**\n * Marks a user as active.\n * @see {@link https://api.slack.com/methods/users.setActive|users.setActive}\n *\n * @param {function} optCb Optional callback, if not using promises.\n */\nUsersFacet.prototype.setActive = function setActive(optCb) {\n  var args = {};\n\n  return this.makeAPICall('users.setActive', args, optCb);\n};\n\n/**\n * Manually sets user presence.\n * @see {@link https://api.slack.com/methods/users.setPresence|users.setPresence}\n *\n * @param {?} presence Either `auto` or `away`\n * @param {function} optCb Optional callback, if not using promises.\n */\nUsersFacet.prototype.setPresence = function setPresence(presence, optCb) {\n  var args = {\n    presence: presence,\n  };\n\n  return this.makeAPICall('users.setPresence', args, optCb);\n};\n\n\nmodule.exports = UsersFacet;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/rtm/client.js":"/**\n *\n * See [the RTM client events](../events/client) for details of the client event lifecycle.\n */\n\nvar bind = require('lodash').bind;\nvar cloneDeep = require('lodash').cloneDeep;\nvar contains = require('lodash').contains;\nvar inherits = require('inherits');\nvar isUndefined = require('lodash').isUndefined;\n\nvar RTM_API_EVENTS = require('../events/rtm').EVENTS;\nvar RTM_CLIENT_INTERNAL_EVENT_TYPES = [\n  'pong',\n  RTM_API_EVENTS.HELLO,\n  RTM_API_EVENTS.TEAM_MIGRATION_STARTED,\n];\nvar UNRECOVERABLE_RTM_START_ERRS = [\n  'not_authed',\n  'invalid_auth',\n  'account_inactive',\n];\nvar CLIENT_EVENTS = require('../events/client').RTM;\nvar BaseAPIClient = require('../client');\nvar RtmFacet = require('../web/facets').RtmFacet;\nvar makeMessageEventWithSubtype = require('../events/utils').makeMessageEventWithSubtype;\nvar wsSocketFn = require('../transports/ws');\n\n\n/**\n *\n * @param {String} token\n * @param {object?} opts\n * @param {Function} opts.socketFn A function to call, passing in a websocket URL, that should\n *     return a websocket instance connected to that URL.\n * @param {object} opts.dataStore A store to cache Slack info, e.g. channels, users etc. in.\n * @param {boolean} opts.autoReconnect Whether or not to automatically reconnect when the connection\n *     closes.\n * @param {number} opts.maxReconnectionAttempts\n * @param {number} opts.reconnectionBackoff\n * @param {number} opts.wsPingInterval\n * @param {number} opts.maxPongInterval\n * @param {string} opts.logLevel The log level for the logger.\n * @param {Function} opts.logger Function to use for log calls, takes (logLevel, logString)\n *     parameters.\n * @param {SlackDataStore} opts.dataStore\n * @constructor\n */\nfunction RTMClient(token, opts) {\n  var clientOpts = opts || {};\n\n  // Force the max request concurrency to 1 for the RTM client. This is because it should not be\n  // trying to rtm.start in parallel.\n  clientOpts.maxRequestConcurrency = 1;\n\n  BaseAPIClient.call(this, token, clientOpts);\n\n  /**\n   * @type {Function}\n   */\n  this._socketFn = clientOpts.socketFn || wsSocketFn;\n\n  /**\n   * The active websocket.\n   * @type {Object}\n   */\n  this.ws = undefined;\n\n  if (!isUndefined(clientOpts.dataStore)) {\n    this.registerDataStore(clientOpts.dataStore);\n  }\n\n  this.MAX_RECONNECTION_ATTEMPTS = clientOpts.maxReconnectionAttempts || 10;\n  this.RECONNECTION_BACKOFF = clientOpts.reconnectionBackoff || 3000;\n  this.MAX_PONG_INTERVAL = clientOpts.maxPongInterval || 10000;\n  this.WS_PING_INTERVAL = clientOpts.wsPingInterval || 5000;\n\n  this.autoReconnect = clientOpts.autoReconnect !== false;\n}\n\ninherits(RTMClient, BaseAPIClient);\n\n\n/**\n * @type {boolean}\n */\nRTMClient.prototype.connected = false;\n\n\n/**\n * @type {boolean}\n */\nRTMClient.prototype.authenticated = false;\n\n\n/**\n * The id of the user that's currently connected via this client.\n * @type {string}\n */\nRTMClient.prototype.activeUserId = undefined;\n\n\n/**\n * The id of the team that's currently connected via this client.\n * @type {string}\n */\nRTMClient.prototype.activeTeamId = undefined;\n\n\n/**\n * Maps message id to message object for messages sent to but not replied to by the remote server.\n * @type {Object}\n * @private\n */\nRTMClient.prototype._pendingMessages = {};\n\n\n/**\n * The timer repeatedly pinging the server to let it know the client is still alive.\n * @type {?}\n */\nRTMClient.prototype._pingTimer = null;\n\n\n/**\n * The time the last pong was received from the server.\n * @type {number}\n * @private\n */\nRTMClient.prototype._lastPong = 0;\n\n\n/**\n *\n * @type {number}\n * @private\n */\nRTMClient.prototype._connAttempts = 0;\n\n\n/**\n * Whether the server is currently connecting.\n * @type {boolean}\n * @private\n */\nRTMClient.prototype._connecting = false;\n\n\n/**\n * Whether the server is currently re-connecting.\n * @type {boolean}\n * @private\n */\nRTMClient.prototype._reconnecting = false;\n\n\n/**\n * @type {SlackDataStore}\n */\nRTMClient.prototype.dataStore = undefined;\n\n\n/** @inheritDoc */\nRTMClient.prototype._createFacets = function _createFacets() {\n  RTMClient.super_.prototype._createFacets.call(this);\n\n  /**\n   * Allows the RTM client to get setup without needing to have a full web client.\n   * @type {RtmFacet}\n   * @private\n   */\n  this._rtm = new RtmFacet(bind(this.makeAPICall, this));\n};\n\n\n/**\n *\n * @param {object} opts\n */\nRTMClient.prototype.start = function start(opts) {\n  // Check whether the client is currently attempting to connect to the RTM API.\n  if (!this._connecting) {\n    this.logger('verbose', 'attempting to connect via the RTM API');\n    this.emit(CLIENT_EVENTS.CONNECTING);\n    this._connecting = true;\n\n    this._rtm.start(opts, bind(this._onStart, this));\n  }\n};\n\n\n/**\n * @deprecated since version 2.0.0, use start() instead.\n */\nRTMClient.prototype.login = function login(opts) {\n  this.start(opts);\n};\n\n\n/**\n * Generates the next message id to use.\n */\nRTMClient.prototype.nextMessageId = function nextMessageId() {\n  this._messageId = this._messageId || 1;\n  return this._messageId++;\n};\n\n\n/**\n *\n * @param err\n * @param data\n * @private\n */\nRTMClient.prototype._onStart = function _onStart(err, data) {\n  var errMsg;\n  this._connecting = false;\n  this._reconnecting = false;\n\n  if (err || !data.url) {\n    this.emit(CLIENT_EVENTS.UNABLE_TO_RTM_START, err || data.error);\n\n    // Any of these mean this client is unusable, so don't attempt to auto-reconnect\n    if (data && contains(UNRECOVERABLE_RTM_START_ERRS, data.error)) {\n      errMsg = 'unrecoverable failure connecting to the RTM API';\n      this.logger('error', errMsg + ': ' + data.error);\n      this.disconnect(errMsg, data.error);\n    } else {\n      this.logger('info', 'unable to RTM start, attempting reconnect: ' + err || data.error);\n      this.authenticated = false;\n      if (this.autoReconnect) {\n        this.reconnect();\n      }\n    }\n  } else {\n    this.logger('verbose', 'rtm.start successful, attempting to open websocket URL');\n    this.authenticated = true;\n    this.activeUserId = data.self.id;\n    this.activeTeamId = data.team.id;\n    if (!isUndefined(this.dataStore)) {\n      this.dataStore.cacheRtmStart(data);\n    }\n\n    this.emit(CLIENT_EVENTS.AUTHENTICATED, data);\n    this.connect(data.url);\n  }\n};\n\n\n/**\n * Closes the websocket and tears down the ping function.\n * @private\n */\nRTMClient.prototype._safeDisconnect = function _safeDisconnect() {\n  if (this._pingTimer) {\n    clearInterval(this._pingTimer);\n    this._pingTimer = null;\n  }\n  if (this.ws) {\n    // Stop listening to the websocket's close event, so that the auto-reconnect logic doesn't fire\n    // twice.\n    this.ws.removeAllListeners('close');\n    this.ws.close();\n  }\n  this.authenticated = false;\n  this.connected = false;\n};\n\n\n/**\n * Connects to the RTM API.\n * @param {string} socketUrl The URL of the websocket to connect to.\n */\nRTMClient.prototype.connect = function connect(socketUrl) {\n  this.emit(CLIENT_EVENTS.WS_OPENING);\n  this.ws = this._socketFn(socketUrl);\n\n  this.ws.on('open', bind(this.handleWsOpen, this));\n  this.ws.on('message', bind(this.handleWsMessage, this));\n  this.ws.on('error', bind(this.handleWsError, this));\n  this.ws.on('close', bind(this.handleWsClose, this));\n  this.ws.on('ping', bind(this.handleWsPing, this));\n};\n\n\n/**\n * Disconnects from the RTM API.\n * @param optReason\n * @param optCode\n */\nRTMClient.prototype.disconnect = function disconnect(optErr, optCode) {\n  this.emit(CLIENT_EVENTS.DISCONNECT, optErr, optCode);\n  this.autoReconnect = false;\n  this._safeDisconnect();\n};\n\n\n/**\n *\n */\nRTMClient.prototype.reconnect = function reconnect() {\n  if (!this._reconnecting) {\n    this.emit(CLIENT_EVENTS.ATTEMPTING_RECONNECT);\n    this._reconnecting = true;\n    this._safeDisconnect();\n\n    // TODO(leah): Update this to remove the reconn logic in the RTM client as it should be covered\n    //             by the web client policy\n    this._connAttempts++;\n    if (this._connAttempts > this.MAX_RECONNECTION_ATTEMPTS) {\n      throw new Error('unable to connect to Slack RTM API, failed after max reconnection attempts');\n    }\n    setTimeout(bind(this.start, this), this._connAttempts * this.RECONNECTION_BACKOFF);\n  }\n};\n\n\n/**\n * Pings the remote server to let it know the client is still alive.\n * @private\n */\nRTMClient.prototype._pingServer = function _pingServer() {\n  var pongInterval;\n\n  if (this.connected) {\n    this.send({ type: 'ping' });\n\n    // If the last pong was more than MAX_PONG_INTERVAL, force a reconnect\n    pongInterval = Date.now() - this._lastPong;\n    if (pongInterval > this.MAX_PONG_INTERVAL) {\n      this.reconnect();\n    }\n  }\n};\n\n\n/**\n * Handler to deal with the WebSocket open event.\n * NOTE: this.connected doesn't get set to true until the helloHandler is called.\n */\nRTMClient.prototype.handleWsOpen = function handleWsOpen() {\n  this.emit(CLIENT_EVENTS.WS_OPENED);\n  this._lastPong = Date.now();\n  this._connAttempts = 0;\n  if (this._pingTimer) {\n    clearInterval(this._pingTimer);\n  } else {\n    this._pingTimer = setInterval(bind(this._pingServer, this), this.WS_PING_INTERVAL);\n  }\n};\n\n\n/**\n * Handler to deal with the WebSocket message event.\n * @param {object} wsMsg\n */\nRTMClient.prototype.handleWsMessage = function handleWsMessage(wsMsg) {\n  var message;\n  this.logger('debug', wsMsg);\n  this.emit(CLIENT_EVENTS.RAW_MESSAGE, wsMsg);\n\n  try {\n    message = JSON.parse(wsMsg);\n  } catch (err) {\n    // TODO(leah): Emit an event here?\n    this.logger('debug', 'unable to parse message: ' + err);\n    return;\n  }\n\n  if (contains(RTM_CLIENT_INTERNAL_EVENT_TYPES, message.type)) {\n    this._handleWsMessageInternal(message.type, message);\n  } else {\n    this._handleWsMessageViaEventHandler(message.type, message);\n  }\n};\n\n\n/**\n *\n * @param {String} messageType\n * @param {Object} message\n * @private\n */\nRTMClient.prototype._handleWsMessageInternal = function _handleWsMessageInternal(\n  messageType, message) {\n  if (messageType === 'pong') {\n    this._handlePong(message);\n  } else if (messageType === RTM_API_EVENTS.HELLO) {\n    this._handleHello();\n  } else if (messageType === RTM_API_EVENTS.TEAM_MIGRATION_STARTED) {\n    this.reconnect();\n    this.emit(messageType, message);\n  }\n};\n\n\n/**\n *\n * @param {String} messageType\n * @param {Object} message\n * @private\n */\nRTMClient.prototype._handleWsMessageViaEventHandler = function _handleWsMessageViaEventHandler(\n  messageType, message) {\n  var replyTo;\n\n  if (messageType === RTM_API_EVENTS.MESSAGE) {\n    replyTo = message.reply_to;\n    if (replyTo) {\n      // TODO(leah): figure out how message pushes via the RTM API should work and how any errors\n      //             will be handled\n      if (this._pendingMessages[replyTo]) {\n        delete this._pendingMessages[replyTo];\n      } else {\n        // If the message was sent in reply to a message that's not on this client, skip the message\n        return;\n      }\n    }\n  }\n\n  if (!isUndefined(this.dataStore)) {\n    this.dataStore.handleRtmMessage(this.activeUserId, this.activeTeamId, messageType, message);\n  }\n\n  this.emit(messageType, message);\n  if (messageType === RTM_API_EVENTS.MESSAGE && !isUndefined(message.subtype)) {\n    this.emit(makeMessageEventWithSubtype(message.subtype), message);\n  }\n};\n\n\n/**\n * Emits the websocket error.\n * @param {Object} err\n */\nRTMClient.prototype.handleWsError = function handleWsError(err) {\n  this.logger('debug', err);\n  this.emit(CLIENT_EVENTS.WS_ERROR, err);\n};\n\n\n/**\n *\n */\nRTMClient.prototype.handleWsClose = function handleWsClose(code, reason) {\n  this.connected = false;\n\n  this.emit(CLIENT_EVENTS.WS_CLOSE, code, reason);\n\n  if (this.autoReconnect) {\n    if (!this._connecting) {\n      this.reconnect();\n    }\n  } else {\n    this.disconnect('websocket closed with auto-reconnect false on the RTM client');\n  }\n};\n\n\n/**\n * Handler for the websocket ping event.\n * This pongs back to the server to let it know the client is still active.\n */\nRTMClient.prototype.handleWsPing = function handleWsPing() {\n  if (this.ws.pong) {\n    this.ws.pong();\n  }\n};\n\n\n/**\n * Handles the server's pong message, updating the lastPong time on the client.\n * @param {Object} message\n */\nRTMClient.prototype._handlePong = function _handlePong(message) {\n  this._lastPong = Date.now();\n  delete this._pendingMessages[message.reply_to];\n};\n\n\n/** {@link https://api.slack.com/events/hello|hello} */\nRTMClient.prototype._handleHello = function _handleHello() {\n  this.connected = true;\n  this.emit(CLIENT_EVENTS.RTM_CONNECTION_OPENED);\n};\n\n\n/**\n * Helper for sending a simple message to a channel|group|DM etc via the RTM API.\n * @param {string} text The text of the messsage to send.\n * @param {string} channelId The id of the channel|group|DM to send this message to.\n * @param {Function=} optCb\n */\nRTMClient.prototype.sendMessage = function sendMessage(text, channelId, optCb) {\n  this.send({\n    text: text,\n    channel: channelId,\n    type: RTM_API_EVENTS.MESSAGE,\n  }, optCb);\n};\n\n\n/**\n * Sends a message over the websocket to the server.\n * @param {*} message The message to send back to the server.\n * @param {Function=} optCb\n */\nRTMClient.prototype.send = function send(message, optCb) {\n  var wsMsg = cloneDeep(message);\n  var jsonMessage;\n  var err;\n  var _this = this;\n\n  if (this.connected) {\n    wsMsg.id = this.nextMessageId();\n    jsonMessage = JSON.stringify(wsMsg);\n    this.logger('debug', jsonMessage);\n\n    this._pendingMessages[wsMsg.id] = wsMsg;\n    this.ws.send(jsonMessage, undefined, function handleWsMsgResponse(wsRespErr) {\n      if (!isUndefined(wsRespErr)) {\n        _this.logger('debug', 'Unable to send message: ' + wsRespErr);\n      }\n\n      if (!isUndefined(optCb)) {\n        optCb(wsRespErr);\n      }\n    });\n  } else {\n    err = 'ws not connected, unable to send message';\n    this.logger('debug', err);\n    if (!isUndefined(optCb)) {\n      optCb(new Error(err));\n    }\n  }\n};\n\n\nmodule.exports = RTMClient;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/events/utils.js":"/**\n *\n */\n\nvar RTM_EVENTS = require('./rtm').EVENTS;\n\n\n/**\n * @param {string} subtype\n * @param {string=} delim\n */\nvar makeMessageEventWithSubtype = function makeMessageEventWithSubtype(subtype, delim) {\n  return [RTM_EVENTS.MESSAGE, subtype].join(delim || '::');\n};\n\n\nmodule.exports.makeMessageEventWithSubtype = makeMessageEventWithSubtype;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/transports/ws.js":"/**\n * Helper to make a new ws WebSocket instance.\n */\n\nvar HttpsProxyAgent = require('https-proxy-agent');\nvar WebSocket = require('ws');\n\n\n/**\n *\n * @param {String} socketUrl\n * @param {Object=} opts\n * @param {String} opts.proxyURL\n * @returns {*}\n */\nvar wsTransport = function wsTransport(socketUrl, opts) {\n  var wsTransportOpts = opts || {};\n  var wsOpts = {};\n\n  if (wsTransportOpts.proxyURL) {\n    wsOpts.agent = new HttpsProxyAgent(wsTransportOpts.proxyUrl);\n  }\n\n  return new WebSocket(socketUrl, wsOpts);\n};\n\nmodule.exports = wsTransport;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/clients/default/legacy-rtm.js":"/**\n * Legacy client implementation mirroring the 1.x.x Slack client implementations.\n */\n\nvar inherits = require('inherits');\n\nvar MemoryDataStore = require('../../data-store/memory-data-store');\nvar RtmClient = require('../rtm/client');\n\n\nfunction LegacyRTMClient(slackToken, autoReconnect) {\n  var opts = {\n    autoReconnect: autoReconnect,\n    logLevel: 'debug',\n    dataStore: new MemoryDataStore(),\n  };\n  RtmClient.call(this, slackToken, opts);\n}\n\ninherits(LegacyRTMClient, RtmClient);\n\n\nmodule.exports = LegacyRTMClient;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/data-store/memory-data-store.js":"/**\n * In memory data store for caching information from the Slack API.\n */\n\nvar assign = require('lodash').assign;\nvar find = require('lodash').find;\nvar has = require('lodash').has;\nvar inherits = require('inherits');\n\nvar SlackDataStore = require('./data-store');\nvar models = require('../models');\n\n\n/**\n *\n * @constructor\n */\nfunction SlackMemoryDataStore(opts) {\n  SlackDataStore.call(this, opts);\n\n  /**\n   *\n   * @type {Object}\n   */\n  this.users = {};\n\n\n  /**\n   *\n   * @type {Object}\n   */\n  this.channels = {};\n\n\n  /**\n   *\n   * @type {Object}\n   */\n  this.dms = {};\n\n\n  /**\n   *\n   * @type {Object}\n   */\n  this.groups = {};\n\n\n  /**\n   *\n   * @type {Object}\n   */\n  this.bots = {};\n\n\n  /**\n   *\n   * @type {Object}\n   */\n  this.teams = {};\n}\n\ninherits(SlackMemoryDataStore, SlackDataStore);\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.clear = function clear() {\n  this.users = {};\n  this.channels = {};\n  this.dms = {};\n  this.groups = {};\n  this.bots = {};\n  this.teams = {};\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.getUserById = function getUserById(userId) {\n  return this.users[userId];\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.getUserByName = function getUserByName(name) {\n  return find(this.users, 'name', name);\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.getUserByEmail = function getUserByEmail(email) {\n  return find(this.users, 'email', email);\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.getChannelById = function getChannelById(channelId) {\n  return this.channels[channelId];\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.getChannelByName = function getChannelByName(name) {\n  var transformedName = name.replace(/^#/, '');\n  return find(this.channels, 'name', transformedName);\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.getGroupById = function getGroupById(groupId) {\n  return this.groups[groupId];\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.getGroupByName = function getGroupByName(name) {\n  return find(this.groups, 'name', name);\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.getDMById = function getDMById(dmId) {\n  return this.dms[dmId];\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.getDMByName = function getDMByName(name) {\n  var user = this.getUserByName(name);\n  return find(this.dms, 'user', user.id);\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.getBotById = function getBotById(botId) {\n  return this.bots[botId];\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.getBotByName = function getBotByName(name) {\n  return find(this.bots, 'name', name);\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.getTeamById = function getTeamById(teamId) {\n  return this.teams[teamId];\n};\n\n\n/**\n * Returns the unread count for all objects: channels, groups etc.\n */\nSlackMemoryDataStore.prototype.getUnreadCount = function getUnreadCount() {\n};\n\n\n// ###############################################\n// Setters\n// ###############################################\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.setChannel = function setChannel(channel) {\n  this.channels[channel.id] = channel;\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.setGroup = function setGroup(group) {\n  this.groups[group.id] = group;\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.setDM = function setDM(dm) {\n  this.dms[dm.id] = dm;\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.setUser = function setUser(user) {\n  this.users[user.id] = user;\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.setBot = function setBot(bot) {\n  this.bots[bot.id] = bot;\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.setTeam = function setTeam(team) {\n  this.teams[team.id] = team;\n};\n\n\n// ###############################################\n// Upserts\n// ###############################################\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.upsertChannel = function upsertChannel(channel) {\n  if (has(this.channels, channel.id)) {\n    this.setChannel(this.getChannelById(channel.id).update(channel));\n  } else {\n    this.setChannel(new models.Channel(channel));\n  }\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.upsertGroup = function upsertGroup(group) {\n  if (has(this.groups, group.id)) {\n    this.setGroup(this.getGroupById(group.id).update(group));\n  } else {\n    this.setGroup(new models.Group(group));\n  }\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.upsertDM = function upsertDM(dm) {\n  if (has(this.dms, dm.id)) {\n    this.setDM(this.getDMById(dm.id).update(dm));\n  } else {\n    this.setDM(new models.DM(dm));\n  }\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.upsertUser = function upsertUser(user) {\n  if (has(this.users, user.id)) {\n    this.setUser(this.getUserById(user.id).update(user));\n  } else {\n    this.setUser(new models.User(user));\n  }\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.upsertBot = function upsertBot(bot) {\n  var currentBot;\n\n  if (has(this.bots, bot.id)) {\n    currentBot = this.getBotById(bot.id);\n    this.setBot(assign(currentBot, bot));\n  } else {\n    this.setBot(bot);\n  }\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.upsertTeam = function upsertTeam(team) {\n  var currentTeam;\n\n  if (has(this.teams, team.id)) {\n    currentTeam = this.getTeamById(team.id);\n    this.setTeam(assign(currentTeam, team));\n  } else {\n    this.setTeam(team);\n  }\n};\n\n\n// ###############################################\n// Deletion methods\n// ###############################################\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.removeChannel = function removeChannel(channelId) {\n  delete this.channels[channelId];\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.removeGroup = function removeGroup(groupId) {\n  delete this.groups[groupId];\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.removeDM = function removeDM(dmId) {\n  delete this.dms[dmId];\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.removeUser = function removeUser(userId) {\n  delete this.users[userId];\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.removeBot = function removeBot(botId) {\n  delete this.bots[botId];\n};\n\n\n/** @inheritdoc */\nSlackMemoryDataStore.prototype.removeTeam = function removeTeam(teamId) {\n  delete this.teams[teamId];\n};\n\n\nmodule.exports = SlackMemoryDataStore;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/data-store/data-store.js":"/* eslint no-unused-vars: 0 */\n\n/**\n * Interface for creating a data store object for caching information from the Slack APIs.\n */\n\nvar bind = require('lodash').bind;\nvar forEach = require('lodash').forEach;\nvar isUndefined = require('lodash').isUndefined;\n\nvar RTM_API_EVENTS = require('../clients/events/rtm').EVENTS;\nvar getLogger = require('../helpers').getLogger;\nvar makeMessageEventWithSubtype = require('../clients/events/utils').makeMessageEventWithSubtype;\nvar messageHandlers = require('./message-handlers');\nvar models = require('../models');\n\n\n/**\n *\n * @param {Object} opts\n * @param {string=} opts.logLevel The log level for the logger.\n * @param {Function=} opts.logger Function to use for log calls, takes (logLevel, logString) params.\n * @constructor\n */\nfunction SlackDataStore(opts) {\n  var dataStoreOpts = opts || {};\n\n  /**\n   * The logger function attached to this client.\n   * @type {Function}\n   */\n  this.logger = dataStoreOpts.logger || getLogger(dataStoreOpts.logLevel);\n\n  forEach(messageHandlers, function anonRegisterMessageHandler(handler, event) {\n    this.registerMessageHandler(event, handler);\n  }, this);\n}\n\n\n/**\n * @type {Object}\n * @private\n */\nSlackDataStore.prototype._messageHandlers = {};\n\n\n/**\n * Sets a handler to save RTM event data to the data-store.\n * @param {string} event\n * @param {function} handler\n */\nSlackDataStore.prototype.registerMessageHandler = function registerMessageHandler(event, handler) {\n  this._messageHandlers[event] = handler;\n};\n\n\n/**\n * Clears the data store and re-sets it to the required starting state.\n */\nSlackDataStore.prototype.clear = function clear() {\n\n};\n\n\n// ###############################################\n// Getters\n// ###############################################\n\n/**\n * Returns the User object matching the supplied id.\n * @param {string} userId\n * @returns {Object}\n */\nSlackDataStore.prototype.getUserById = function getUserById(userId) {\n};\n\n\n/**\n * Returns the User object matching the supplied name.\n * @param {string} name\n * @returns {Object}\n */\nSlackDataStore.prototype.getUserByName = function getUserByName(name) {\n};\n\n\n/**\n * Returns the User object matching the supplied email.\n * @param {string} email\n * @returns {Object}\n */\nSlackDataStore.prototype.getUserByEmail = function getUserByEmail(email) {\n};\n\n\n/**\n * Returns the Channel object matching the supplied id.\n * @param channelId\n * @returns {Object}\n */\nSlackDataStore.prototype.getChannelById = function getChannelById(channelId) {\n};\n\n\n/**\n * Returns the Channel object matching the supplied name.\n * @param name\n * @returns {Object}\n */\nSlackDataStore.prototype.getChannelByName = function getChannelByName(name) {\n};\n\n\n/**\n * Returns the Group object matching the supplied id.\n * @param groupId\n * @returns {Object}\n */\nSlackDataStore.prototype.getGroupById = function getGroupById(groupId) {\n};\n\n\n/**\n * Returns the Group object matching the supplied name.\n * @param name\n * @returns {Object}\n */\nSlackDataStore.prototype.getGroupByName = function getGroupByName(name) {\n\n};\n\n\n/**\n * Returns the DM object matching the supplied id.\n * @param dmId\n * @returns {Object}\n */\nSlackDataStore.prototype.getDMById = function getDMById(dmId) {\n\n};\n\n\n/**\n * Returns the DM object between the registered user and the user with the supplied name.\n * @param name\n * @return {Object}\n */\nSlackDataStore.prototype.getDMByName = function getDMByName(name) {\n\n};\n\n\n/**\n * Returns the bot object matching the supplied id.\n * @param botId\n * @returns {Object}\n */\nSlackDataStore.prototype.getBotById = function getBotById(botId) {\n\n};\n\n\n/**\n * Returns the bot object matching the supplied name.\n * @param {string} name\n * @returns {Object}\n */\nSlackDataStore.prototype.getBotByName = function getBotByName(name) {\n\n};\n\n\n/**\n * Returns the bot object matching the supplied name.\n * @param {string} name\n * @returns {Object}\n */\nSlackDataStore.prototype.getTeamById = function getTeamById(name) {\n\n};\n\n\n/**\n * Returns the unread count for all objects: channels, groups etc.\n */\nSlackDataStore.prototype.getUnreadCount = function getUnreadCount() {\n};\n\n\n// ###############################################\n// Setters\n// ###############################################\n\n\n/**\n * Stores a channel object in the data store.\n * @param {Object} channel\n */\nSlackDataStore.prototype.setChannel = function setChannel(channel) {\n};\n\n\n/**\n *\n * @param {Object} group\n */\nSlackDataStore.prototype.setGroup = function setGroup(group) {\n};\n\n\n/**\n *\n * @param {Object} dm\n */\nSlackDataStore.prototype.setDM = function setDM(dm) {\n};\n\n\n/**\n *\n * @param {Object} user\n */\nSlackDataStore.prototype.setUser = function setUser(user) {\n};\n\n\n/**\n *\n * @param {Object} bot\n */\nSlackDataStore.prototype.setBot = function setBot(bot) {\n};\n\n\n/**\n * @param {Object} team\n */\nSlackDataStore.prototype.setTeam = function setTeam(team) {\n};\n\n\n// ###############################################\n// Upserts\n// ###############################################\n\n\n/** @param channel */\nSlackDataStore.prototype.upsertChannel = function upsertChannel(channel) {\n\n};\n\n\n/** @param group */\nSlackDataStore.prototype.upsertGroup = function upsertGroup(group) {\n\n};\n\n\n/** @param dm */\nSlackDataStore.prototype.upsertDM = function upsertDM(dm) {\n\n};\n\n\n/** @param user */\nSlackDataStore.prototype.upsertUser = function upsertUser(user) {\n\n};\n\n\n/** @param bot */\nSlackDataStore.prototype.upsertBot = function upsertBot(bot) {\n\n};\n\n\n/** @param team */\nSlackDataStore.prototype.upsertTeam = function upsertTeam(team) {\n\n};\n\n\n// ###############################################\n// Deletion methods\n// ###############################################\n\n\nSlackDataStore.prototype.removeChannel = function removeChannel(channelId) {\n};\n\n\nSlackDataStore.prototype.removeGroup = function removeGroup(groupId) {\n};\n\n\nSlackDataStore.prototype.removeDM = function removeDM(dmId) {\n};\n\n\nSlackDataStore.prototype.removeUser = function removeUser(userId) {\n};\n\n\nSlackDataStore.prototype.removeBot = function removeBot(botId) {\n};\n\n\nSlackDataStore.prototype.removeTeam = function removeTeam(teamId) {\n};\n\n// ###############################################\n// Helpers\n// ###############################################\n\n/**\n *\n * @param id\n * @param obj\n */\nSlackDataStore.prototype.upsertChannelGroupOrDMById = function upsertChannelGroupOrDMById(id, obj) {\n  var firstChar = id.substring(0, 1);\n\n  if (firstChar === 'C') {\n    this.upsertChannel(obj);\n  } else if (firstChar === 'G') {\n    this.upsertGroup(obj);\n  } else if (firstChar === 'D') {\n    this.upsertDM(obj);\n  }\n};\n\n\n/**\n * Returns the channel, group or DM object matching the supplied Id.\n * @param objId\n * @returns {Object}\n */\nSlackDataStore.prototype.getChannelGroupOrDMById = function getChannelGroupOrDMById(objId) {\n  var firstChar = objId.substring(0, 1);\n\n  if (firstChar === 'C') {\n    return this.getChannelById(objId);\n  } else if (firstChar === 'G') {\n    return this.getGroupById(objId);\n  } else if (firstChar === 'D') {\n    return this.getDMById(objId);\n  }\n};\n\n\n/**\n * Returns the channel or group object matching name, finding by channel, then group then DM.\n * @param objId\n * @returns {Object}\n */\nSlackDataStore.prototype.getChannelOrGroupByName = function getChannelOrGroupByName(name) {\n  var channel = this.getChannelByName(name);\n  return channel ? channel : this.getGroupByName(name);\n};\n\n\n// ###############################################\n// Web API response handlers\n// ###############################################\n\n/**\n * Caches an {@link https://api.slack.com/methods/rtm.start|rtm.start} response to the datastore.\n * @param {Object} data\n */\nSlackDataStore.prototype.cacheRtmStart = function cacheRtmStart(data) {\n  this.clear();\n\n  forEach(data.users || [], function cacheRtmUser(user) {\n    this.setUser(new models.User(user));\n  }, this);\n  forEach(data.channels || [], function cacheRtmChannel(channel) {\n    this.setChannel(new models.Channel(channel));\n  }, this);\n  forEach(data.ims || [], function cacheRtmDM(dm) {\n    this.setDM(new models.DM(dm));\n  }, this);\n  forEach(data.groups || [], function cacheRtmGroup(group) {\n    this.setGroup(new models.Group(group));\n  }, this);\n  forEach(data.bots || [], function cacheRtmBot(bot) {\n    // Bots don't have a separate type currently, so treat them as simple objects\n    this.setBot(bot);\n  }, this);\n\n  this.getUserById(data.self.id).update(data.self);\n  this.setTeam(data.team);\n};\n\n\n// ###############################################\n// RTM Message handlers\n// ###############################################\n\n\n/**\n *\n * @param {string} activeUserId\n * @param {string} activeTeamId\n * @param {string} messageType\n * @param {Object} message\n */\nSlackDataStore.prototype.handleRtmMessage = function handleRtmMessage(\n  activeUserId, activeTeamId, messageType, message) {\n  var handler;\n  if (messageType === RTM_API_EVENTS.MESSAGE && !isUndefined(message.subtype)) {\n    handler = this._messageHandlers[makeMessageEventWithSubtype(message.subtype)];\n\n    // If there's a custom handler for the message subtype, use that, otherwise default to adding\n    // the message to the base channel history\n    handler = handler ?\n      handler : this._messageHandlers[makeMessageEventWithSubtype('rtm_client_add_message')];\n  } else {\n    handler = this._messageHandlers[messageType];\n  }\n\n  if (!isUndefined(handler)) {\n    try {\n      // Some handlers require the active user / team id, so support providing it as needed\n      if (handler.length === 4) {\n        handler(activeUserId, activeTeamId, this, message);\n      } else {\n        handler(this, message);\n      }\n    } catch (err) {\n      // TODO(leah): Do something more here?\n      this.logger('debug', err);\n    }\n  }\n};\n\n\nmodule.exports = SlackDataStore;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/data-store/message-handlers/index.js":"/**\n *\n */\n\nvar forEach = require('lodash').forEach;\n\n\nvar handlerModules = [\n  require('./bots'),\n  require('./channels'),\n  require('./groups'),\n  require('./dm'),\n  require('./presence'),\n  require('./stars'),\n  require('./team'),\n  require('./user'),\n  require('./message'),\n  require('./reactions'),\n];\n\n\nforEach(handlerModules, function registerHandlerModule(mod) {\n  forEach(mod, function registerHandlerFn(val, key) {\n    module.exports[key] = val;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/data-store/message-handlers/bots.js":"/**\n * Handlers for all RTM `bot_*` events.\n */\n\nvar zipObject = require('lodash').zipObject;\n\nvar RTM_EVENTS = require('../../clients/events/rtm').EVENTS;\n\n\n/** {@link https://api.slack.com/events/bot_added|bot_added} */\nvar addBot = function addBot(dataStore, message) {\n  dataStore.setBot(message.bot);\n};\n\n\n/** {@link https://api.slack.com/events/bot_changed|bot_changed} */\nvar changedBot = function changedBot(dataStore, message) {\n  dataStore.upsertBot(message.bot);\n};\n\n\nvar handlers = [\n  [RTM_EVENTS.BOT_ADDED, addBot],\n  [RTM_EVENTS.BOT_CHANGED, changedBot],\n];\n\n\nmodule.exports = zipObject(handlers);\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/data-store/message-handlers/channels.js":"/**\n * Handlers for all RTM `channel_` events.\n */\n\nvar zipObject = require('lodash').zipObject;\n\nvar RTM_EVENTS = require('../../clients/events/rtm').EVENTS;\n\nvar baseChannelHandlers = require('./base-channel');\nvar helpers = require('./helpers');\nvar models = require('../../models');\n\n\nvar addChannel = function addChannel(dataStore, message) {\n  var newChannel = new models.Channel(message);\n  dataStore.setChannel(newChannel);\n};\n\n\n/** {@link https://api.slack.com/events/channel_created|channel_created} */\nvar handleChannelCreated = function handleChannelCreated(dataStore, message) {\n  addChannel(dataStore, message.channel);\n};\n\n\n/** {@link https://api.slack.com/events/channel_deleted|channel_deleted} */\nvar handleChannelDeleted = function handleChannelDeleted(dataStore, message) {\n  var channelId = message.channel;\n  dataStore.removeChannel(channelId);\n};\n\n\n/** {@link https://api.slack.com/events/channel_joined|channel_joined} */\nvar handleChannelJoined = function handleChannelJoined(dataStore, message) {\n  dataStore.upsertChannel(message.channel);\n};\n\n/** {@link https://api.slack.com/events/channel_left|channel_left} */\nvar handleChannelLeft = function handleChannelLeft(activeUserId, activeTeamId, dataStore, message) {\n  var channel;\n  baseChannelHandlers.handleLeave(activeUserId, activeTeamId, dataStore, message);\n  channel = dataStore.getChannelById(message.channel);\n  if (channel) {\n    channel.is_member = false;\n  }\n};\n\nvar handlers = [\n  [RTM_EVENTS.CHANNEL_ARCHIVE, baseChannelHandlers.handleArchive],\n  [RTM_EVENTS.CHANNEL_CREATED, handleChannelCreated],\n  [RTM_EVENTS.CHANNEL_DELETED, handleChannelDeleted],\n  [RTM_EVENTS.CHANNEL_HISTORY_CHANGED, helpers.noopMessage],\n  [RTM_EVENTS.CHANNEL_JOINED, handleChannelJoined],\n  [RTM_EVENTS.CHANNEL_LEFT, handleChannelLeft],\n  [RTM_EVENTS.CHANNEL_MARKED, baseChannelHandlers.handleChannelGroupOrDMMarked],\n  [RTM_EVENTS.CHANNEL_RENAME, baseChannelHandlers.handleRename],\n  [RTM_EVENTS.CHANNEL_UNARCHIVE, baseChannelHandlers.handleUnarchive],\n];\n\n\nmodule.exports = zipObject(handlers);\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/data-store/message-handlers/base-channel.js":"/**\n * Event handlers that can be re-used between channels, groups and DMs\n */\n\n\nvar setBaseChannelProperty = function setBaseChannelProperty(val, key) {\n  return function setBaseChannelPropertyWrapped(dataStore, message) {\n    var obj = dataStore.getChannelGroupOrDMById(message.channel);\n    if (obj) {\n      obj[key] = val;\n    }\n  };\n};\n\n\n/**\n * {@link https://api.slack.com/events/channel_marked|channel_marked}\n * {@link https://api.slack.com/events/group_marked|group_marked}\n * {@link https://api.slack.com/events/im_marked|im_marked}\n */\nvar handleChannelGroupOrDMMarked = function handleChannelGroupOrDMMarked(dataStore, message) {\n  var firstChar;\n\n  var baseChannel = dataStore.getChannelGroupOrDMById(message.channel);\n\n  if (baseChannel) {\n    baseChannel.lastRead = message.ts;\n    baseChannel.recalcUnreads();\n\n    firstChar = message.channel.substring(0, 1);\n\n    if (firstChar === 'C') {\n      dataStore.setChannel(baseChannel);\n    } else if (firstChar === 'G') {\n      dataStore.setGroup(baseChannel);\n    } else if (firstChar === 'D') {\n      dataStore.setDM(baseChannel);\n    }\n  }\n};\n\n\n/**\n * {@link https://api.slack.com/events/channel_archive|channel_archive}\n * {@link https://api.slack.com/events/group_archive|group_archive}\n */\nvar handleArchive = setBaseChannelProperty(true, 'is_archived');\n\n\n/**\n * {@link https://api.slack.com/events/channel_unarchive|channel_unarchive}\n * {@link https://api.slack.com/events/group_unarchive|group_unarchive}\n */\nvar handleUnarchive = setBaseChannelProperty(false, 'is_archived');\n\n\n/**\n * {@link https://api.slack.com/events/group_rename|group_rename}\n * {@link https://api.slack.com/events/channel_rename|channel_rename}\n */\nvar handleRename = function handleRename(dataStore, message) {\n  dataStore.upsertChannelGroupOrDMById(message.channel.id, message.channel);\n};\n\n\n/**\n * {@link https://api.slack.com/events/group_left|group_left}\n * {@link https://api.slack.com/events/channel_left|channel_left}\n */\nvar handleLeave = function handleLeave(activeUserId, activeTeamId, dataStore, message) {\n  var index;\n\n  var baseChannel = dataStore.getChannelGroupOrDMById(message.channel);\n  if (baseChannel) {\n    index = baseChannel.members.indexOf(activeUserId);\n    baseChannel.members.splice(index, 1);\n  }\n};\n\n\nmodule.exports.handleChannelGroupOrDMMarked = handleChannelGroupOrDMMarked;\nmodule.exports.handleArchive = handleArchive;\nmodule.exports.handleUnarchive = handleUnarchive;\nmodule.exports.handleRename = handleRename;\nmodule.exports.handleLeave = handleLeave;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/data-store/message-handlers/helpers.js":"/**\n *\n */\n\nvar models = require('../../models');\n\n\nvar noopMessage = function noopMessage(dataStore, message) {\n  return message;\n};\n\n\n/**\n * {@link https://api.slack.com/events/team_join|team_join}\n * {@link https://api.slack.com/events/user_change|user_change}\n */\nvar handleNewOrUpdatedUser = function handleNewOrUpdatedUser(dataStore, message) {\n  var user = dataStore.getUserById(message.user.id);\n  if (user) {\n    user.update(message.user);\n  } else {\n    user = new models.User(message.user);\n  }\n  dataStore.setUser(user);\n};\n\n\nmodule.exports.handleNewOrUpdatedUser = handleNewOrUpdatedUser;\nmodule.exports.noopMessage = noopMessage;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/models/index.js":"module.exports = {\n  Channel: require('./channel'),\n  DM: require('./dm'),\n  File: require('./file'),\n  Group: require('./group'),\n  MPDM: require('./mpdm'),\n  User: require('./user'),\n  UserGroup: require('./user-group'),\n};\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/models/channel.js":"/**\n * {@link https://api.slack.com/types/channel|Channel}\n */\n\nvar inherits = require('inherits');\n\nvar ChannelGroup = require('./channel-group');\n\n\nvar Channel = function Channel(opts) {\n  ChannelGroup.call(this, 'Channel', opts);\n};\n\ninherits(Channel, ChannelGroup);\n\n\nmodule.exports = Channel;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/models/channel-group.js":"/**\n *\n */\n\nvar inherits = require('inherits');\n\nvar BaseChannel = require('./base-channel');\n\n\nvar ChannelGroup = function ChannelGroup(name, opts) {\n  BaseChannel.call(this, name, opts);\n};\n\ninherits(ChannelGroup, BaseChannel);\n\n\nmodule.exports = ChannelGroup;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/models/base-channel.js":"/**\n *\n */\n\nvar bind = require('lodash').bind;\nvar forEachRight = require('lodash').forEachRight;\nvar find = require('lodash').find;\nvar findLastIndex = require('lodash').findLastIndex;\nvar inherits = require('inherits');\nvar keys = require('lodash').keys;\n\nvar Model = require('./model');\n\n\nfunction BaseChannel(objectName, opts) {\n  /**\n   *\n   * @type {Array}\n   */\n  this.history = [];\n\n  /**\n   * Object, keyed on user id, values of timeouts that will be run to clear the user typing state.\n   * @type {{}}\n   * @private\n   */\n  this._typing = {};\n\n  /**\n   *\n   */\n  this.unreadCount = 0;\n\n\n  /**\n   * @type {string}\n   */\n  this.lastRead = '0000000000.000000';\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this._maxTs = '0000000000.000000';\n\n  Model.call(this, objectName, opts);\n}\n\ninherits(BaseChannel, Model);\n\n\n/**\n * The timeout after which the user typing entry should be removed.\n * @type {number}\n */\nBaseChannel.prototype.USER_TYPING_TIMEOUT = 5000;\n\n\nBaseChannel.prototype._setProperties = function setProperties(opts) {\n  BaseChannel.super_.prototype._setProperties.call(this, opts);\n\n  if (this.latest) {\n    this.addMessage(this.latest);\n  }\n};\n\n\n/**\n *\n * @param {string} userId\n */\nBaseChannel.prototype.startedTyping = function startedTyping(userId) {\n  if (this._typing[userId]) {\n    clearTimeout(this._typing[userId]);\n  }\n\n  this._typing[userId] = setTimeout(bind(function removeSetTypingTimeout() {\n    delete this._typing[userId];\n  }, this), this.USER_TYPING_TIMEOUT);\n};\n\n\n/**\n *\n * @returns {number}\n */\nBaseChannel.prototype.recalcUnreads = function recalcUnreads() {\n  this.unreadCount = 0;\n  forEachRight(this.history, function checkMessageIsUnread(message) {\n    if (message.ts > this.lastRead) {\n      this.unreadCount++;\n    } else {\n      return false;\n    }\n  }, this);\n\n  return this.unreadCount;\n};\n\n\n/**\n * Returns the string form of the channel type.\n * @return {string}\n */\nBaseChannel.prototype.getType = function getType() {\n  return this._modelName.toLowerCase();\n};\n\n\n/**\n * Returns an array of user ids for all users who are currently typing.\n * @return {Array.<string>}\n */\nBaseChannel.prototype.getTypingUsers = function getTypingUsers() {\n  return keys(this._typing);\n};\n\n\n/**\n *\n * @param ts\n */\nBaseChannel.prototype.getMessageByTs = function getMessageByTs(ts) {\n  // This has the potential to get really slow, but ok for now I guess...\n  return find(this.history, { ts: ts });\n};\n\n\n/**\n *\n * @param {Object} message\n */\nBaseChannel.prototype.addMessage = function addMessage(message) {\n  // TODO(leah): Do a reverse walk of this and compare the timestamps as an extra guarantee?\n  this.history.push(message);\n\n  if (message.ts > this._maxTs && !message.hidden) {\n    this._maxTs = message.ts;\n    this.unreadCount++;\n  }\n};\n\n\nBaseChannel.prototype.updateMessage = function updateMessage(messageUpdatedMsg) {\n  var message = messageUpdatedMsg.message;\n  var msgIndex = findLastIndex(this.history, 'ts', message.ts);\n  if (msgIndex !== -1) {\n    this.history[msgIndex] = message;\n  }\n};\n\n\nmodule.exports = BaseChannel;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/models/model.js":"/**\n *\n */\n\nvar forEach = require('lodash').forEach;\nvar has = require('lodash').has;\nvar isArray = require('lodash').isArray;\nvar isEmpty = require('lodash').isEmpty;\nvar isObject = require('lodash').isObject;\nvar map = require('lodash').map;\nvar mapValues = require('lodash').mapValues;\n\nvar PROPERTY_TYPES = require('./property-type');\nvar helpers = require('./helpers');\n\n\nfunction Model(name, opts) {\n  /**\n   *\n   * @type {Object}\n   * @protected\n   */\n  this._properties = {};\n\n  /**\n   * The name of the model.\n   * @type {string}\n   * @private\n   */\n  this._modelName = name;\n\n  this._setProperties(isEmpty(opts) ? {} : opts);\n}\n\n\n/**\n * Updates the model.\n * @param {Object} opts\n * @return {Object} The model object that was just updated.\n */\nModel.prototype.update = function update(opts) {\n  this._setProperties(opts);\n  return this;\n};\n\n\n/**\n * Assigns all properties from the supplied opts object to the model.\n *\n * Subclasses of the model class have the opportunity to intelligently set defaults or assign values\n * via individual assignment calls by extending this method on the subclass.\n *\n * @param {Object} opts\n * @private\n */\nModel.prototype._setProperties = function setProperties(opts) {\n  forEach(opts, this._setModelProperty, this);\n};\n\n\n/**\n * Assigns an individual property from a Slack API response to a model object.\n *\n * Property assignment works by:\n *   1. If the property does not exist, set the property.\n *   2. If the property exists on the model, and is a scalar, overwrite the property with the\n *      property from the opts object\n *   3. If the property exists on the model and is a complex property:\n *      * if it's an object, extend the model property with values from the opts property\n *      * if it's an array, overwrite the array. This is because it's currently unclear if there are\n *        any array properties that will only be partially filled by some RTM / API responses, but\n *        completely filled by others.\n *\n * @param {String} key\n * @param {*} val\n *cchnnihbtckbllbflvffbvrgelvkufcruclebldbdtbb\n * @private\n */\nModel.prototype._setModelProperty = function _setModelProperty(val, key) {\n  if (isObject(val)) {\n    this._setObjectProperty(key, val);\n  } else if (isArray(val)) {\n    this._setArrayProperty(key, val);\n  } else {\n    this._properties[key] = PROPERTY_TYPES.SIMPLE;\n    this[key] = val;\n  }\n};\n\n\n/**\n * Sets an object property from the API on a model object.\n *\n * NOTE: this assumes that none of the values of the object from the API represent additional model\n *       objects, i.e. that {relevantChannel: {channelObject}} will never occur in the API response.\n *\n * @param key\n * @param val\n *\n * @private\n */\nModel.prototype._setObjectProperty = function _setObjectProperty(key, val) {\n  var hasProperty = has(this, key);\n  var ModelClass;\n\n  if (helpers.isModelObj(val)) {\n    if (hasProperty) {\n      this[key].update(val);\n    } else {\n      ModelClass = helpers.getModelClass();\n      this[key] = new ModelClass(val);\n    }\n    this._properties[key] = PROPERTY_TYPES.MODEL;\n  } else {\n    this._properties[key] = PROPERTY_TYPES.SIMPLE;\n    this[key] = val;\n  }\n};\n\n\n/**\n *\n * @param key\n * @param val\n *\n * @private\n */\nModel.prototype._setArrayProperty = function _setArrayProperty(key, val) {\n  var ModelClass;\n  var firstItem;\n\n  // NOTE: This assumes that it's not necessary to search and update model values in arrays and\n  //       that instead they can be over-written\n  if (!isEmpty(val)) {\n    // Assumes that all values in the array are of the same type\n    firstItem = val[0];\n    if (helpers.isModelObj(firstItem)) {\n      ModelClass = helpers.getModelClass();\n      this[key] = map(val, function makeChildModelObjs(item) {\n        return new ModelClass(item);\n      });\n      this._properties[key] = PROPERTY_TYPES.MODEL_ARRAY;\n    } else {\n      this._properties[key] = PROPERTY_TYPES.SIMPLE;\n      this[key] = val;\n    }\n  } else {\n    this._properties[key] = PROPERTY_TYPES.SIMPLE;\n    this[key] = val;\n  }\n};\n\n\nModel.prototype.toJSON = function toJSON() {\n  var objRepresentation = mapValues(this._properties, function mapModelPropertiesToJSON(val, key) {\n    var res;\n\n    if (val === PROPERTY_TYPES.MODEL) {\n      res = this[key].toJSON();\n    } else if (val === PROPERTY_TYPES.MODEL_ARRAY) {\n      res = map(this[key], function mapModelArrayPropertyToJSON(arrVal) {\n        return arrVal.toJSON();\n      });\n    } else {\n      res = this[key];\n    }\n\n    return res;\n  }, this);\n\n  return objRepresentation;\n};\n\n\nmodule.exports = Model;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/models/property-type.js":"var PROPERTY_TYPES = {\n  SIMPLE: 0,\n  MODEL: 1,\n  MODEL_ARRAY: 2,\n};\n\nmodule.exports = PROPERTY_TYPES;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/models/helpers.js":"var hasKey = require('lodash').has;\n\n// Channel, file, group, DM, user, usergroup\nvar RECOGNIZED_API_TYPE_PREFIXES = ['C', 'F', 'G', 'D', 'U', 'S'];\n\n\n/**\n * Tests whether a supplied JSON object represents a Slack API type.\n * @param {Object} obj\n * @returns {boolean}\n */\nvar isModelObj = function isModelObj(obj) {\n  if (hasKey(obj, 'id')) {\n    return RECOGNIZED_API_TYPE_PREFIXES.indexOf(obj.id.substr(0, 1)) !== -1;\n  }\n\n  return false;\n};\n\n\n/**\n * Returns the model class for the JSON object from the Slack API.\n */\nvar getModelClass = function getModelClass(obj) {\n  var apiTypePrefix = obj.id.substr(0, 1);\n\n  switch (apiTypePrefix) {\n    case 'C':\n      return require('./channel');\n    case 'F':\n      return require('./file');\n    case 'D':\n      return require('./dm');\n    case 'U':\n      return require('./user');\n    case 'S':\n      return require('./user-group');\n\n    default:\n      // The MPDM and Group classes share the same prefix, so do an extra check here\n      if (apiTypePrefix === 'G') {\n        if (obj.is_mpim) {\n          return require('./mpdm');\n        }\n\n        if (obj.is_group) {\n          return require('./group');\n        }\n      }\n  }\n};\n\n\nmodule.exports.isModelObj = isModelObj;\nmodule.exports.getModelClass = getModelClass;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/models/dm.js":"/**\n * {@link https://api.slack.com/types/im|DM}\n */\n\nvar inherits = require('inherits');\n\nvar BaseChannel = require('./base-channel');\n\n\nfunction DM(opts) {\n  BaseChannel.call(this, 'DM', opts);\n}\n\ninherits(DM, BaseChannel);\n\n\nmodule.exports = DM;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/models/file.js":"/**\n *\n */\n\nvar inherits = require('inherits');\n\nvar Model = require('./model');\n\n\nfunction File(opts) {\n  Model.call(this, 'File', opts);\n}\n\ninherits(File, Model);\n\n\nmodule.exports = File;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/models/group.js":"/**\n * {@link https://api.slack.com/types/group|Group}\n */\n\nvar inherits = require('inherits');\n\nvar ChannelGroup = require('./channel-group');\n\n\nfunction Group(opts) {\n  ChannelGroup.call(this, 'Group', opts);\n}\n\ninherits(Group, ChannelGroup);\n\n\nmodule.exports = Group;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/models/mpdm.js":"/**\n *\n */\n\nvar inherits = require('inherits');\n\nvar ChannelGroup = require('./channel-group');\n\n\nfunction MPDM(opts) {\n  ChannelGroup.call(this, 'MPDM', opts);\n}\n\ninherits(MPDM, ChannelGroup);\n\n\nmodule.exports = MPDM;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/models/user.js":"/**\n *\n */\n\nvar inherits = require('inherits');\n\nvar Model = require('./model');\n\n\nfunction User(opts) {\n  Model.call(this, 'User', opts);\n}\n\ninherits(User, Model);\n\n\nmodule.exports = User;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/models/user-group.js":"/**\n *\n */\n\nvar inherits = require('inherits');\n\nvar Model = require('./model');\n\n\nfunction UserGroup(opts) {\n  Model.call(this, 'UserGroup', opts);\n}\n\ninherits(UserGroup, Model);\n\n\nmodule.exports = UserGroup;\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/data-store/message-handlers/groups.js":"/**\n * Handlers for all RTM `group_` events.\n */\n\nvar zipObject = require('lodash').zipObject;\n\nvar RTM_EVENTS = require('../../clients/events/rtm').EVENTS;\n\nvar baseChannelHandlers = require('./base-channel');\nvar helpers = require('./helpers');\nvar models = require('../../models');\n\n\n/** {@link https://api.slack.com/events/group_joined|group_joined} */\nvar handleGroupJoined = function handleGroupJoined(dataStore, message) {\n  var group = new models.Group(message.channel);\n  dataStore.setGroup(group);\n};\n\n\n/**\n * {@link https://api.slack.com/events/group_left|group_left}\n */\nvar handleGroupLeave = function handleGroupLeave(activeUserId, activeTeamId, dataStore, message) {\n  var group;\n  baseChannelHandlers.handleLeave(activeUserId, activeTeamId, dataStore, message);\n\n  group = dataStore.getGroupById(message.channel);\n  if (group) {\n    // TODO(leah): Maybe this should remove the group?\n    if (group.members.length === 0) {\n      group.is_archived = true;\n    }\n    dataStore.setGroup(group);\n  }\n};\n\n\nvar handlers = [\n  [RTM_EVENTS.GROUP_ARCHIVE, baseChannelHandlers.handleArchive],\n  [RTM_EVENTS.GROUP_CLOSE, helpers.noopMessage],\n  [RTM_EVENTS.GROUP_JOINED, handleGroupJoined],\n  [RTM_EVENTS.GROUP_LEFT, handleGroupLeave],\n  [RTM_EVENTS.GROUP_MARKED, baseChannelHandlers.handleChannelGroupOrDMMarked],\n  [RTM_EVENTS.GROUP_OPEN, helpers.noopMessage],\n  [RTM_EVENTS.GROUP_UNARCHIVE, baseChannelHandlers.handleUnarchive],\n  [RTM_EVENTS.GROUP_RENAME, baseChannelHandlers.handleRename],\n  [RTM_EVENTS.GROUP_HISTORY_CHANGED, helpers.noopMessage],\n];\n\n\nmodule.exports = zipObject(handlers);\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/data-store/message-handlers/dm.js":"/**\n * Handlers for all RTM `im_` events.\n */\n\nvar zipObject = require('lodash').zipObject;\n\nvar RTM_EVENTS = require('../../clients/events/rtm').EVENTS;\nvar baseChannelHandlers = require('./base-channel');\nvar helpers = require('./helpers');\nvar models = require('../../models');\n\n\n/** {@link https://api.slack.com/events/im_created|im_created} */\nvar handleDMCreated = function handleDMCreated(dataStore, message) {\n  var dm = new models.DM(message.channel);\n  dataStore.setDM(dm);\n};\n\n\nvar changeDMOpenness = function changeDMOpenness(dataStore, message, isOpen) {\n  var dm = dataStore.getDMById(message.channel);\n\n  if (dm) {\n    dm.is_open = isOpen;\n    dataStore.setDM(dm);\n  }\n};\n\n\n/** {@link https://api.slack.com/events/im_close|im_close} */\nvar handleDMClose = function handleDMClose(dataStore, message) {\n  return changeDMOpenness(dataStore, message, false);\n};\n\n\n/** {@link https://api.slack.com/events/im_open|im_open} */\nvar handleDMOpen = function handleDMOpen(dataStore, message) {\n  return changeDMOpenness(dataStore, message, true);\n};\n\n\nvar handlers = [\n  [RTM_EVENTS.IM_CREATED, handleDMCreated],\n  [RTM_EVENTS.IM_MARKED, baseChannelHandlers.handleChannelGroupOrDMMarked],\n  [RTM_EVENTS.IM_OPEN, handleDMOpen],\n  [RTM_EVENTS.IM_CLOSE, handleDMClose],\n  [RTM_EVENTS.IM_HISTORY_CHANGED, helpers.noopMessage],\n];\n\n\nmodule.exports = zipObject(handlers);\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/data-store/message-handlers/presence.js":"/**\n * Event handlers for RTM presence change events.\n */\n\nvar zipObject = require('lodash').zipObject;\n\nvar RTM_EVENTS = require('../../clients/events/rtm').EVENTS;\n\n\n/** {@link https://api.slack.com/events/manual_presence_change|manual_presence_change} */\nvar handleManualPresenceChange = function handleManualPresenceChange(\n  activeUserId, activeTeamId, dataStore, message) {\n  var user = dataStore.getUserById(activeUserId);\n  user.presence = message.presence;\n};\n\n\n/** {@link https://api.slack.com/events/presence_change|presence_change} */\nvar handlePresenceChange = function handlePresenceChange(dataStore, message) {\n  var user = dataStore.getUserById(message.user);\n  user.presence = message.presence;\n};\n\n\nvar handlers = [\n  [RTM_EVENTS.MANUAL_PRESENCE_CHANGE, handleManualPresenceChange],\n  [RTM_EVENTS.PRESENCE_CHANGE, handlePresenceChange],\n];\n\n\nmodule.exports = zipObject(handlers);\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/data-store/message-handlers/stars.js":"/**\n * Handlers for all RTM `star_` events.\n */\n\nvar zipObject = require('lodash').zipObject;\n\nvar RTM_EVENTS = require('../../clients/events/rtm').EVENTS;\nvar helpers = require('./helpers');\n\n\nvar handlers = [\n  [RTM_EVENTS.STAR_ADDED, helpers.noopMessage],\n  [RTM_EVENTS.STAR_REMOVED, helpers.noopMessage],\n];\n\n\nmodule.exports = zipObject(handlers);\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/data-store/message-handlers/team.js":"/**\n * Handlers for all RTM `team_` events.\n */\nvar zipObject = require('lodash').zipObject;\n\nvar RTM_EVENTS = require('../../clients/events/rtm').EVENTS;\n\nvar helpers = require('./helpers');\n\n\n/** {@link https://api.slack.com/events/team_domain_change|team_domain_change} */\nvar handleTeamDomainChange = function handleTeamDomainChange(\n  activeUserId, activeTeamId, dataStore, message) {\n  var team = dataStore.getTeamById(activeTeamId);\n  team.domain = message.domain;\n  team.url = message.url;\n  dataStore.setTeam(team);\n};\n\n\n/** {@link https://api.slack.com/events/team_rename|team_rename} */\nvar handleTeamRename = function handleTeamRename(activeUserId, activeTeamId, dataStore, message) {\n  var team = dataStore.getTeamById(activeTeamId);\n  team.name = message.name;\n  dataStore.setTeam(team);\n};\n\n\n/** {@link https://api.slack.com/events/team_pref_change|team_pref_change} */\nvar handleTeamPrefChange = function handleTeamPrefChange(\n  activeUserId, activeTeamId, dataStore, message) {\n  var team = dataStore.getTeamById(activeTeamId);\n  team.prefs[message.name] = message.value;\n  dataStore.setTeam(team);\n};\n\n\nvar handlers = [\n  [RTM_EVENTS.TEAM_DOMAIN_CHANGE, handleTeamDomainChange],\n  [RTM_EVENTS.TEAM_RENAME, handleTeamRename],\n  [RTM_EVENTS.TEAM_PREF_CHANGE, handleTeamPrefChange],\n  [RTM_EVENTS.TEAM_JOIN, helpers.handleNewOrUpdatedUser],\n];\n\n\nmodule.exports = zipObject(handlers);\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/data-store/message-handlers/user.js":"/**\n * Handlers for all RTM `user_*` events.\n */\n\nvar zipObject = require('lodash').zipObject;\n\nvar RTM_EVENTS = require('../../clients/events/rtm').EVENTS;\n\nvar helpers = require('./helpers');\n\n\n/** {@link https://api.slack.com/events/user_typing|user_typing} */\nvar handleUserTyping = function handleUserTyping(dataStore, message) {\n  var user = dataStore.getUserById(message.user);\n  var channel = dataStore.getChannelById(message.channel);\n\n  if (channel && user) {\n    channel.startedTyping(user.id);\n  } else {\n    // TODO(leah): Logs for when channel / user aren't found.\n  }\n};\n\n\n/** {@link https://api.slack.com/events/pref_change|pref_change} */\nvar handlePrefChange = function handlePrefChange(activeUserId, activeTeamId, dataStore, message) {\n  var user = dataStore.getUserById(activeUserId);\n  user.prefs[message.name] = message.value;\n};\n\n\nvar handlers = [\n  [RTM_EVENTS.PREF_CHANGE, handlePrefChange],\n  [RTM_EVENTS.USER_TYPING, handleUserTyping],\n  [RTM_EVENTS.USER_CHANGE, helpers.handleNewOrUpdatedUser],\n];\n\n\nmodule.exports = zipObject(handlers);\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/data-store/message-handlers/message.js":"/**\n * Handlers for all `message` event subtypes.\n */\n\nvar findIndex = require('lodash').findIndex;\nvar zipObject = require('lodash').zipObject;\n\nvar MESSAGE_SUBTYPES = require('../../clients/events/rtm').MESSAGE_SUBTYPES;\nvar makeMessageEventWithSubtype = require('../../clients/events/utils').makeMessageEventWithSubtype;\n\n\nvar addMessageToChannel = function addMessageToChannel(dataStore, message) {\n  var baseChannel = dataStore.getChannelGroupOrDMById(message.channel);\n  baseChannel.addMessage(message);\n};\n\n\n/**\n * {@link https://api.slack.com/events/message/channel_join|channel_join}\n * {@link https://api.slack.com/events/message/group_join|group_join}\n */\nvar baseChannelJoin = function baseChannelJoin(dataStore, message) {\n  var baseChannel = dataStore.getChannelGroupOrDMById(message.channel);\n\n  if (baseChannel.members.indexOf(message.user) === -1) {\n    baseChannel.members.push(message.user);\n  }\n\n  baseChannel.addMessage(message);\n};\n\n\n/**\n * {@link https://api.slack.com/events/message/channel_join|channel_join}\n * {@link https://api.slack.com/events/message/group_join|group_join}\n */\nvar baseChannelLeave = function baseChannelLeave(dataStore, message) {\n  var baseChannel = dataStore.getChannelGroupOrDMById(message.channel);\n\n  var memberIndex = baseChannel.members.indexOf(message.user);\n  if (memberIndex !== -1) {\n    baseChannel.members.splice(memberIndex, 1);\n  }\n\n  baseChannel.addMessage(message);\n};\n\n\n/** {@link https://api.slack.com/events/message/message_deleted|message_deleted} */\nvar baseChannelMessageDeleted = function baseChannelMessageDeleted(dataStore, message) {\n  var baseChannel = dataStore.getChannelGroupOrDMById(message.channel);\n  var msgIndex = findIndex(baseChannel.history, 'ts', message.deleted_ts);\n  baseChannel.history.splice(msgIndex, 1);\n  baseChannel.addMessage(message);\n};\n\n\n/** {@link https://api.slack.com/events/message/message_changed|message_changed} */\nvar baseChannelMessageChanged = function baseChannelMessageChanged(dataStore, message) {\n  var baseChannel = dataStore.getChannelGroupOrDMById(message.channel);\n  baseChannel.updateMessage(message);\n  baseChannel.addMessage(message);\n};\n\n\nvar handlers = [\n  [makeMessageEventWithSubtype(MESSAGE_SUBTYPES.MESSAGE_DELETED), baseChannelMessageDeleted],\n  [makeMessageEventWithSubtype(MESSAGE_SUBTYPES.MESSAGE_CHANGED), baseChannelMessageChanged],\n  [makeMessageEventWithSubtype(MESSAGE_SUBTYPES.CHANNEL_JOIN), baseChannelJoin],\n  [makeMessageEventWithSubtype(MESSAGE_SUBTYPES.CHANNEL_LEAVE), baseChannelLeave],\n  [makeMessageEventWithSubtype(MESSAGE_SUBTYPES.GROUP_JOIN), baseChannelJoin],\n  [makeMessageEventWithSubtype(MESSAGE_SUBTYPES.GROUP_LEAVE), baseChannelLeave],\n  // Add in a default handler for all other message subtypes\n  [makeMessageEventWithSubtype('rtm_client_add_message'), addMessageToChannel],\n];\n\n\nmodule.exports = zipObject(handlers);\n","/home/travis/build/npmtest/node-npmtest-slack-client/node_modules/slack-client/lib/data-store/message-handlers/reactions.js":"/**\n * Handlers for all RTM `reaction_xxx` events.\n */\n\nvar findIndex = require('lodash').findIndex;\nvar partial = require('lodash').partial;\nvar zipObject = require('lodash').zipObject;\n\nvar RTM_EVENTS = require('../../clients/events/rtm').EVENTS;\n\n\n/**\n *\n * @param {Object} dataStore\n * @param {Object} message\n * @param {boolean} isAdded\n */\nvar toggleReactionForMessage = function toggleReactionForMessage(dataStore, message, isAdded) {\n  var reaction;\n  var reactionIndex;\n  var userIndex;\n  var item = message.item;\n\n  var channel = dataStore.getChannelGroupOrDMById(item.channel);\n  var msgObj = channel.getMessageByTs(item.ts);\n\n  // Ensure a reactions array is available on the message object\n  msgObj.reactions = msgObj.reactions || [];\n\n  // If there's a message in the local cache, update it, otherwise do nothing as the message\n  // with reaction will get populated when it's next needed from history.\n  if (message) {\n    reactionIndex = findIndex(msgObj.reactions, { name: message.reaction });\n    reaction = msgObj.reactions[reactionIndex];\n\n    if (reaction) {\n      reaction.count = Math.max(reaction.count + (isAdded ? 1 : -1), 0);\n\n      if (isAdded) {\n        // NOTE: This will not necessarily be consistent with the users array if the\n        //       message is pulled from the server. This is because the server only stores\n        //       X users per reaction, whereas the client will store as many as it's\n        //       notified about.\n        reaction.users.push(message.user);\n      } else {\n        if (reaction.count === 0) {\n          msgObj.reactions.splice(reactionIndex, 1);\n        } else {\n          userIndex = reaction.users.indexOf(message.user);\n          if (userIndex > -1) {\n            reaction.users.splice(userIndex, 1);\n          }\n        }\n      }\n    } else {\n      msgObj.reactions.push({\n        name: message.reaction,\n        users: [message.user],\n        count: 1,\n      });\n    }\n  }\n};\n\n\nvar toggleReactionForFile = function toggleReactionForFile() {\n  // TODO(leah): Update this once files are supported in the data-store implementation\n};\n\n\nvar toggleReactionForFileComment = function toggleReactionForFileComment() {\n  // TODO(leah): Update this once files are supported in the data-store implementation\n};\n\n\nvar toggleReaction = function toggleReaction(isAdded, dataStore, message) {\n  var itemType = message.item.type;\n\n  if (itemType === 'file') {\n    toggleReactionForFile(dataStore, message, isAdded);\n  } else if (itemType === 'file_comment') {\n    toggleReactionForFileComment(dataStore, message, isAdded);\n  } else if (itemType === 'message') {\n    toggleReactionForMessage(dataStore, message, isAdded);\n  }\n};\n\n\nvar handlers = [\n  [RTM_EVENTS.REACTION_ADDED, partial(toggleReaction, true)],\n  [RTM_EVENTS.REACTION_REMOVED, partial(toggleReaction, false)],\n];\n\n\nmodule.exports = zipObject(handlers);\n"}